{
  "endpoints": {
    "admin_tech": {
      "type": "endpoint",
      "methods": [
        "delete",
        "download",
        "generate",
        "get",
        "get_all"
      ]
    },
    "admin_tech.session": {
      "type": "endpoint",
      "methods": [
        "about",
        "close",
        "delete",
        "get",
        "get_adapter",
        "get_data",
        "get_file",
        "get_full_url",
        "get_json",
        "get_redirect_target",
        "get_tenant_id",
        "head",
        "login",
        "logout",
        "merge_environment_settings",
        "mount",
        "options",
        "patch",
        "post",
        "prepare_request",
        "put",
        "rebuild_auth",
        "rebuild_method",
        "rebuild_proxies",
        "request",
        "resolve_redirects",
        "response_trace",
        "restart_imminent",
        "send",
        "server",
        "should_strip_auth",
        "wait_server_ready"
      ]
    },
    "admin_tech.session.adapters": {
      "type": "endpoint",
      "methods": [
        "fromkeys",
        "get",
        "move_to_end",
        "popitem",
        "setdefault"
      ]
    },
    "admin_tech.session.api": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.api_version": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.cookies": {
      "type": "endpoint",
      "methods": [
        "add_cookie_header",
        "clear",
        "clear_expired_cookies",
        "clear_session_cookies",
        "copy",
        "extract_cookies",
        "get",
        "get_dict",
        "get_policy",
        "items",
        "iteritems",
        "iterkeys",
        "itervalues",
        "keys",
        "list_domains",
        "list_paths",
        "make_cookies",
        "multiple_domains",
        "pop",
        "popitem",
        "set",
        "set_cookie",
        "set_cookie_if_ok",
        "set_policy",
        "setdefault",
        "update",
        "values"
      ]
    },
    "admin_tech.session.endpoints": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.administration_user_and_group": {
      "type": "endpoint",
      "methods": [
        "create_colo_group",
        "create_group_grid_columns",
        "create_resource_group",
        "create_user",
        "create_user_group",
        "create_vpn_group",
        "delete_colo_group",
        "delete_resource_group",
        "delete_user",
        "delete_user_group",
        "delete_vpn_group",
        "edit_colo_group",
        "edit_vpn_group",
        "find_resource_groups",
        "find_user_auth_type",
        "find_user_groups",
        "find_user_groups_as_key_value",
        "find_user_role",
        "find_users",
        "get_active_sessions",
        "get_colo_groups",
        "get_vpn_groups",
        "remove_sessions",
        "reset_user",
        "resource_group_name",
        "switch_resource_group",
        "update_admin_password",
        "update_password",
        "update_profile_locale",
        "update_profile_password",
        "update_resource_group",
        "update_user",
        "update_user_group",
        "validate_password"
      ]
    },
    "admin_tech.session.endpoints.certificate_management_device": {
      "type": "endpoint",
      "methods": [
        "change_vedge_list_validity",
        "delete_configuration",
        "generate_csr",
        "generate_csr_task",
        "send_to_controllers",
        "send_to_vbond"
      ]
    },
    "admin_tech.session.endpoints.certificate_management_vmanage": {
      "type": "endpoint",
      "methods": [
        "dump_certificate",
        "get_certificate",
        "get_csr",
        "import_certificate",
        "rollback",
        "show_info"
      ]
    },
    "admin_tech.session.endpoints.client": {
      "type": "endpoint",
      "methods": [
        "about",
        "server",
        "server_ready"
      ]
    },
    "admin_tech.session.endpoints.cluster_management": {
      "type": "endpoint",
      "methods": [
        "add_or_update_user_credentials",
        "add_vmanage",
        "check_if_cluster_locked",
        "configure_vmanage",
        "edit_vmanage",
        "get_cluster_workflow_version",
        "get_configured_ip_list",
        "get_connected_devices",
        "get_connected_devices_per_tenant",
        "get_tenancy_mode",
        "get_tenants_list",
        "get_vmanage_details",
        "health_details",
        "health_status_info",
        "health_summary",
        "is_cluster_ready",
        "list_vmanages",
        "node_properties",
        "perform_replication_and_rebalance_of_kafka_partitions",
        "remove_vmanage",
        "set_tenancy_mode"
      ]
    },
    "admin_tech.session.endpoints.configuration": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.configuration.feature_profile": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.configuration.policy": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.configuration_dashboard_status": {
      "type": "endpoint",
      "methods": [
        "find_running_tasks",
        "find_status"
      ]
    },
    "admin_tech.session.endpoints.configuration_device_actions": {
      "type": "endpoint",
      "methods": [
        "create_filter_vpn_list",
        "create_unique_vpn_list",
        "create_vpn_list",
        "generate_change_partition_info",
        "generate_deactivate_info",
        "generate_device_action_list",
        "generate_install_info",
        "generate_reboot_device_list",
        "generate_reboot_info",
        "generate_rediscover_info",
        "generate_remove_partition_info",
        "generate_security_devices_list",
        "get_list_of_installed_devices",
        "get_ztp_upgrade_config",
        "get_ztp_upgrade_config_setting",
        "initiate_image_download",
        "process_amp_api_re_key",
        "process_cancel_task",
        "process_deactivate_smu",
        "process_delete_amp_api_key",
        "process_install_operation",
        "process_lxc_activate",
        "process_lxc_delete",
        "process_lxc_install",
        "process_lxc_reload",
        "process_lxc_reset",
        "process_lxc_upgrade",
        "process_mark_change_partition",
        "process_mark_default_partition",
        "process_reboot",
        "process_remove_partition",
        "process_remove_software_image",
        "process_vnf_install",
        "process_ztp_upgrade_config",
        "process_ztp_upgrade_config_setting",
        "re_discover_all_device",
        "re_discover_devices",
        "test_api_key",
        "test_iox_config",
        "trigger_pending_tasks_monitoring"
      ]
    },
    "admin_tech.session.endpoints.configuration_device_inventory": {
      "type": "endpoint",
      "methods": [
        "create_device",
        "delete_device",
        "generate_bootstrap_configuration",
        "get_device_details",
        "sync_devices_from_smart_account",
        "unlock",
        "upload_wan_edge_list"
      ]
    },
    "admin_tech.session.endpoints.configuration_device_software_update": {
      "type": "endpoint",
      "methods": [
        "download_package_file",
        "edit_image_metadata",
        "get_image_metadata",
        "get_upload_images_count",
        "process_software_image",
        "upload_software_to_manager"
      ]
    },
    "admin_tech.session.endpoints.configuration_device_template": {
      "type": "endpoint",
      "methods": [
        "get_device_configuration_preview"
      ]
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery": {
      "type": "endpoint",
      "methods": [
        "activate",
        "delete",
        "get_details",
        "get_disaster_recovery_local_replication_schedule",
        "get_disaster_recovery_status",
        "get_dr_status",
        "get_local_history",
        "get_reachability_info",
        "get_remote_data_center_details",
        "get_remote_data_center_version",
        "pause_dr",
        "register",
        "unpause_dr"
      ]
    },
    "admin_tech.session.endpoints.configuration_feature_profile": {
      "type": "endpoint",
      "methods": [
        "create_aaa_profile_parcel_for_system",
        "create_cellular_controller_profile_parcel_for_transport",
        "create_sdwan_system_feature_profile",
        "create_sdwan_transport_feature_profile",
        "delete_sdwan_system_feature_profile",
        "delete_sdwan_transport_feature_profile",
        "get_sdwan_feature_profiles",
        "get_sdwan_system_aaa_parcel_schema",
        "get_sdwan_system_feature_profiles",
        "get_sdwan_transport_cellular_controller_parcel_schema",
        "get_sdwan_transport_feature_profiles"
      ]
    },
    "admin_tech.session.endpoints.configuration_group": {
      "type": "endpoint",
      "methods": [
        "associate",
        "create_config_group",
        "create_variables",
        "delete_config_group",
        "deploy",
        "disassociate",
        "edit_config_group",
        "get",
        "update_variables"
      ]
    },
    "admin_tech.session.endpoints.configuration_settings": {
      "type": "endpoint",
      "methods": [
        "create_analytics_data_file",
        "edit_banner",
        "edit_cert_configuration",
        "edit_certificates",
        "edit_claim_device",
        "edit_client_session_timeout",
        "edit_cloudservices",
        "edit_cloudx",
        "edit_configuration",
        "edit_configuration_by_setting_type",
        "edit_data_collection_on_notification",
        "edit_devices",
        "edit_elasticsearch_db_size",
        "edit_email_notification_settings",
        "edit_google_map_key",
        "edit_hardware_root_cas",
        "edit_ips_signature_settings",
        "edit_maintenance_window",
        "edit_manage_encrypted_password",
        "edit_max_sessions_per_user",
        "edit_organizations",
        "edit_password_policy",
        "edit_pnp_connect_sync",
        "edit_proxy_http_servers",
        "edit_reverse_proxies",
        "edit_sdwan_telemetry",
        "edit_server_session_timeout",
        "edit_session_life_time",
        "edit_smart_account_credentials",
        "edit_smart_licensing_settings",
        "edit_software_install_timeout",
        "edit_sp_metadata",
        "edit_stats_config",
        "edit_vedge_cloud",
        "edit_vmanage_data_stream",
        "edit_walkme",
        "get_banner",
        "get_cert_configuration",
        "get_certificates",
        "get_claim_device",
        "get_client_session_timeout",
        "get_cloudservices",
        "get_cloudx",
        "get_clr_settings",
        "get_configuration_by_setting_type",
        "get_data_collection_on_notification",
        "get_devices",
        "get_elasticsearch_db_size",
        "get_email_notification_settings",
        "get_google_map_key",
        "get_hardware_root_cas",
        "get_ips_signature_settings",
        "get_maintenance_window",
        "get_manage_encrypted_password",
        "get_max_sessions_per_user",
        "get_organizations",
        "get_password_policy",
        "get_pnp_connect_sync",
        "get_proxy_http_servers",
        "get_reverse_proxies",
        "get_sdwan_telemetry",
        "get_server_session_timeout",
        "get_session_life_time",
        "get_smart_account_credentials",
        "get_smart_licensing_settings",
        "get_software_install_timeout",
        "get_sp_metadata",
        "get_stats_config",
        "get_vedge_cloud",
        "get_vmanage_data_stream",
        "get_walkme",
        "new_cert_configuration",
        "new_configuration"
      ]
    },
    "admin_tech.session.endpoints.configuration_software_actions": {
      "type": "endpoint",
      "methods": [
        "add_new_remote_server",
        "delete_software_from_software_repository",
        "get_list_of_all_images",
        "get_list_of_remote_servers",
        "get_remote_server",
        "get_software_images",
        "remove_remote_server",
        "update_remote_server",
        "upload_software_from_remote_server"
      ]
    },
    "admin_tech.session.endpoints.misc": {
      "type": "endpoint",
      "methods": [
        "get_application_protocols"
      ]
    },
    "admin_tech.session.endpoints.monitoring_device_details": {
      "type": "endpoint",
      "methods": [
        "add_tier",
        "delete_tier",
        "enable_sdavcon_device",
        "generate_device_state_data",
        "generate_device_state_data_fields",
        "generate_device_state_data_with_query_string",
        "get_all_device_status",
        "get_device_counters",
        "get_device_list_as_key_value",
        "get_device_models",
        "get_device_only_status",
        "get_device_running_config",
        "get_device_running_config_html",
        "get_device_tloc_status",
        "get_device_tloc_util",
        "get_device_tloc_util_details",
        "get_hardware_health_details",
        "get_hardware_health_summary",
        "get_stats_queues",
        "get_sync_queues",
        "get_tiers",
        "get_unconfigured",
        "get_vedge_inventory",
        "get_vedge_inventory_summary",
        "get_vmanage_system_ip",
        "list_all_device_models",
        "list_all_devices",
        "list_all_monitor_details_devices",
        "list_currently_syncing_devices",
        "list_reachable_devices",
        "list_unreachable_devices",
        "remove_unreachable_device",
        "set_block_sync",
        "sync_all_devices_mem_db"
      ]
    },
    "admin_tech.session.endpoints.monitoring_security_policy": {
      "type": "endpoint",
      "methods": [
        "get_device_list"
      ]
    },
    "admin_tech.session.endpoints.monitoring_server_info": {
      "type": "endpoint",
      "methods": [
        "get_server_info"
      ]
    },
    "admin_tech.session.endpoints.monitoring_status": {
      "type": "endpoint",
      "methods": [
        "get_disabled_device_list",
        "get_enabled_index_for_device",
        "get_statistics_settings",
        "update_statistics_device_list",
        "update_statistics_settings"
      ]
    },
    "admin_tech.session.endpoints.real_time_monitoring": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.real_time_monitoring.reboot_history": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile": {
      "type": "endpoint",
      "methods": [
        "create_cli_feature_profile",
        "create_cli_full_config_parcel",
        "delete_cli_feature_profile",
        "delete_cli_full_config_parcel",
        "edit_cli_full_config_parcel",
        "get_cli_feature_profiles"
      ]
    },
    "admin_tech.session.endpoints.sdavc_cloud_connector": {
      "type": "endpoint",
      "methods": [
        "disable_cloud_connector",
        "enable_cloud_connector",
        "get_cloud_connector",
        "get_cloud_connector_status"
      ]
    },
    "admin_tech.session.endpoints.tenant_backup_restore": {
      "type": "endpoint",
      "methods": [
        "delete_tenant_backup",
        "download_existing_backup_file",
        "export_tenant_backup",
        "import_tenant_backup",
        "list_tenant_backup"
      ]
    },
    "admin_tech.session.endpoints.tenant_management": {
      "type": "endpoint",
      "methods": [
        "create_tenant",
        "create_tenant_async",
        "create_tenant_async_bulk",
        "delete_tenant",
        "delete_tenant_async_bulk",
        "force_status_collection",
        "get_all_tenant_statuses",
        "get_all_tenants",
        "get_tenant",
        "get_tenant_hosting_capacity_on_vsmarts",
        "get_tenant_vsmart_mapping",
        "switch_tenant",
        "tenant_vsmart_mt_migrate",
        "update_tenant",
        "update_tenant_vsmart_placement",
        "vsession_id"
      ]
    },
    "admin_tech.session.endpoints.tenant_migration": {
      "type": "endpoint",
      "methods": [
        "download_tenant_data",
        "export_tenant_data",
        "get_migration_token",
        "import_tenant_data",
        "import_tenant_data_with_key",
        "migrate_network",
        "retrigger_network_migration"
      ]
    },
    "admin_tech.session.endpoints.troubleshooting_tools": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.troubleshooting_tools.device_connectivity": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.endpoints.url_monitoring": {
      "type": "endpoint",
      "methods": [
        "add_url_monitor",
        "delete_url_monitor",
        "get_url_monitor",
        "update_url_monitor"
      ]
    },
    "admin_tech.session.headers": {
      "type": "endpoint",
      "methods": [
        "clear",
        "copy",
        "get",
        "items",
        "keys",
        "lower_items",
        "pop",
        "popitem",
        "setdefault",
        "update",
        "values"
      ]
    },
    "admin_tech.session.logger": {
      "type": "endpoint",
      "methods": [
        "addFilter",
        "addHandler",
        "callHandlers",
        "critical",
        "debug",
        "error",
        "exception",
        "fatal",
        "filter",
        "findCaller",
        "getChild",
        "getChildren",
        "getEffectiveLevel",
        "handle",
        "hasHandlers",
        "info",
        "isEnabledFor",
        "log",
        "makeRecord",
        "removeFilter",
        "removeHandler",
        "setLevel",
        "warn",
        "warning"
      ]
    },
    "admin_tech.session.logger.manager": {
      "type": "endpoint",
      "methods": [
        "getLogger",
        "setLogRecordFactory",
        "setLoggerClass"
      ]
    },
    "admin_tech.session.logger.manager.root": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.logger.parent": {
      "type": "endpoint",
      "methods": [
        "addFilter",
        "addHandler",
        "callHandlers",
        "critical",
        "debug",
        "error",
        "exception",
        "fatal",
        "filter",
        "findCaller",
        "getChild",
        "getChildren",
        "getEffectiveLevel",
        "handle",
        "hasHandlers",
        "info",
        "isEnabledFor",
        "log",
        "makeRecord",
        "removeFilter",
        "removeHandler",
        "setLevel",
        "warn",
        "warning"
      ]
    },
    "admin_tech.session.logger.parent.manager": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.logger.parent.root": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.logger.root": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.session_type": {
      "type": "endpoint",
      "methods": []
    },
    "admin_tech.session.state": {
      "type": "endpoint",
      "methods": []
    },
    "administration_settings": {
      "type": "endpoint",
      "methods": [
        "disable_sdavc_cloud_connector",
        "enable_cloud_on_ramp_for_saas_mode",
        "enable_sdavc_cloud_connector",
        "get_cloud_on_ramp_for_saas_mode",
        "get_cloud_services",
        "get_organization",
        "get_sdavc_cloud_connector_config",
        "get_software_install_timeout",
        "set_cloud_services",
        "set_software_install_timeout",
        "update"
      ]
    },
    "administration_settings.session": {
      "type": "endpoint",
      "methods": []
    },
    "alarms": {
      "type": "endpoint",
      "methods": [
        "check_alarms",
        "get",
        "mark_all_as_viewed"
      ]
    },
    "alarms.session": {
      "type": "endpoint",
      "methods": []
    },
    "cluster_management": {
      "type": "endpoint",
      "methods": [
        "get_cluster_management_health_status",
        "modify_cluster_setup"
      ]
    },
    "cluster_management.session": {
      "type": "endpoint",
      "methods": []
    },
    "config_device_inventory_api": {
      "type": "endpoint",
      "methods": [
        "generate_bootstrap_cfg",
        "unlock"
      ]
    },
    "config_device_inventory_api.endpoint": {
      "type": "endpoint",
      "methods": [
        "create_device",
        "delete_device",
        "generate_bootstrap_configuration",
        "get_device_details",
        "sync_devices_from_smart_account",
        "unlock",
        "upload_wan_edge_list"
      ]
    },
    "config_device_inventory_api.session": {
      "type": "endpoint",
      "methods": []
    },
    "config_group": {
      "type": "endpoint",
      "methods": [
        "associate",
        "create",
        "create_variables",
        "delete",
        "deploy",
        "disassociate",
        "edit",
        "get",
        "update_variables"
      ]
    },
    "config_group.endpoint": {
      "type": "endpoint",
      "methods": [
        "associate",
        "create_config_group",
        "create_variables",
        "delete_config_group",
        "deploy",
        "disassociate",
        "edit_config_group",
        "get",
        "update_variables"
      ]
    },
    "config_group.session": {
      "type": "endpoint",
      "methods": []
    },
    "dashboard": {
      "type": "endpoint",
      "methods": [
        "get_bfd_connectivity_count",
        "get_certificates_status",
        "get_control_statuses_count",
        "get_devices_count",
        "get_devices_health",
        "get_devices_health_overview",
        "get_edges_inventory_count",
        "get_licensed_devices",
        "get_tenant_status",
        "get_transport_health",
        "get_transport_interface_distribution",
        "get_tunnel_health",
        "get_vmanages_count"
      ]
    },
    "dashboard.session": {
      "type": "endpoint",
      "methods": []
    },
    "device_state": {
      "type": "endpoint",
      "methods": [
        "enable_data_stream",
        "get_bfd_sessions",
        "get_colors",
        "get_device_control_connections_info",
        "get_device_crash_info",
        "get_device_orchestrator_connections_info",
        "get_device_reboot_history",
        "get_device_wan_interfaces",
        "get_system_status",
        "wait_for_bfd_session_up",
        "wait_for_device_state"
      ]
    },
    "device_state.session": {
      "type": "endpoint",
      "methods": []
    },
    "devices": {
      "type": "endpoint",
      "methods": [
        "count_devices",
        "get",
        "get_device_details",
        "get_reachable_devices",
        "get_system_ip_based_on_local_system_ip",
        "send_certificate_state_to_controllers"
      ]
    },
    "devices.session": {
      "type": "endpoint",
      "methods": []
    },
    "logs": {
      "type": "endpoint",
      "methods": [
        "get_auditlogs"
      ]
    },
    "logs.session": {
      "type": "endpoint",
      "methods": []
    },
    "lxcsoftware": {
      "type": "endpoint",
      "methods": [
        "lxcactivate",
        "lxcdelete",
        "lxcupgrade"
      ]
    },
    "lxcsoftware.device_versions": {
      "type": "endpoint",
      "methods": [
        "get_device_available",
        "get_device_list",
        "get_device_list_in_installed",
        "get_devices_available_versions",
        "get_devices_current_version",
        "get_lxcactivate_device_list",
        "get_lxcupgrade_device_list"
      ]
    },
    "lxcsoftware.device_versions.repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "lxcsoftware.device_versions.repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "lxcsoftware.repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "lxcsoftware.repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "lxcsoftware.session": {
      "type": "endpoint",
      "methods": []
    },
    "omp": {
      "type": "endpoint",
      "methods": [
        "get_advertised_routes",
        "get_advertised_tlocs",
        "get_omp_peers",
        "get_omp_summary",
        "get_received_routes",
        "get_received_tlocs",
        "get_services"
      ]
    },
    "omp.session": {
      "type": "endpoint",
      "methods": []
    },
    "packet_capture": {
      "type": "endpoint",
      "methods": [
        "channel",
        "download_capture_session",
        "get_interface_name",
        "get_packets",
        "get_status",
        "start_stop"
      ]
    },
    "packet_capture.session": {
      "type": "endpoint",
      "methods": []
    },
    "partition": {
      "type": "endpoint",
      "methods": [
        "remove_partition",
        "set_default_partition"
      ]
    },
    "partition.device_version": {
      "type": "endpoint",
      "methods": [
        "get_device_available",
        "get_device_list",
        "get_device_list_in_installed",
        "get_devices_available_versions",
        "get_devices_current_version",
        "get_lxcactivate_device_list",
        "get_lxcupgrade_device_list"
      ]
    },
    "partition.device_version.repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "partition.device_version.repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "partition.repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "partition.repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "partition.session": {
      "type": "endpoint",
      "methods": []
    },
    "policy": {
      "type": "endpoint",
      "methods": [
        "delete_any",
        "get_protocol_map"
      ]
    },
    "policy.centralized": {
      "type": "endpoint",
      "methods": [
        "activate",
        "check_vsmart_connectivity",
        "create",
        "deactivate",
        "delete",
        "edit",
        "get"
      ]
    },
    "policy.definitions": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "edit",
        "get"
      ]
    },
    "policy.lists": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "edit",
        "get"
      ]
    },
    "policy.localized": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "edit",
        "get",
        "list_devices",
        "preview"
      ]
    },
    "policy.security": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "edit",
        "get"
      ]
    },
    "repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "resource_groups": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get",
        "switch",
        "update"
      ]
    },
    "resource_groups.session": {
      "type": "endpoint",
      "methods": []
    },
    "resource_pool": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get"
      ]
    },
    "resource_pool.session": {
      "type": "endpoint",
      "methods": []
    },
    "sd_routing_feature_profiles": {
      "type": "endpoint",
      "methods": []
    },
    "sd_routing_feature_profiles.cli": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "init_parcels"
      ]
    },
    "sd_routing_feature_profiles.cli.endpoint": {
      "type": "endpoint",
      "methods": [
        "create_cli_feature_profile",
        "create_cli_full_config_parcel",
        "delete_cli_feature_profile",
        "delete_cli_full_config_parcel",
        "edit_cli_full_config_parcel",
        "get_cli_feature_profiles"
      ]
    },
    "sd_routing_feature_profiles.cli.session": {
      "type": "endpoint",
      "methods": []
    },
    "sd_routing_feature_profiles.policy_object": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get",
        "update"
      ]
    },
    "sd_routing_feature_profiles.policy_object.endpoint": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get_all",
        "get_by_id",
        "update"
      ]
    },
    "sd_routing_feature_profiles.policy_object.session": {
      "type": "endpoint",
      "methods": []
    },
    "sessions": {
      "type": "endpoint",
      "methods": [
        "get",
        "invalidate"
      ]
    },
    "sessions.session": {
      "type": "endpoint",
      "methods": []
    },
    "software": {
      "type": "endpoint",
      "methods": [
        "activate",
        "install"
      ]
    },
    "software.device_versions": {
      "type": "endpoint",
      "methods": [
        "get_device_available",
        "get_device_list",
        "get_device_list_in_installed",
        "get_devices_available_versions",
        "get_devices_current_version",
        "get_lxcactivate_device_list",
        "get_lxcupgrade_device_list"
      ]
    },
    "software.device_versions.repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "software.device_versions.repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "software.repository": {
      "type": "endpoint",
      "methods": [
        "delete_image",
        "get_all_software_images",
        "get_all_virtual_images",
        "get_devices_versions_repository",
        "get_image_version",
        "get_remote_image",
        "upload_image"
      ]
    },
    "software.repository.session": {
      "type": "endpoint",
      "methods": []
    },
    "software.session": {
      "type": "endpoint",
      "methods": []
    },
    "speedtest": {
      "type": "endpoint",
      "methods": [
        "speedtest"
      ]
    },
    "speedtest.session": {
      "type": "endpoint",
      "methods": []
    },
    "templates": {
      "type": "endpoint",
      "methods": [
        "attach",
        "create",
        "create_by_generator",
        "deatach",
        "delete",
        "edit",
        "edit_before_push",
        "generate_feature_template_payload",
        "get",
        "get_device_configuration_preview",
        "get_feature_template_schema",
        "is_created_by_generator",
        "load_running",
        "template_validation",
        "validate_device_model"
      ]
    },
    "templates.session": {
      "type": "endpoint",
      "methods": []
    },
    "tenant_backup": {
      "type": "endpoint",
      "methods": [
        "delete",
        "delete_all",
        "download",
        "export",
        "import_file",
        "list"
      ]
    },
    "tenant_backup.session": {
      "type": "endpoint",
      "methods": []
    },
    "tenant_management": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get",
        "get_hosting_capacity_on_vsmarts",
        "get_statuses",
        "get_vsmart_mapping",
        "update",
        "update_vsmart_placement",
        "vsession_id"
      ]
    },
    "tenant_management.session": {
      "type": "endpoint",
      "methods": []
    },
    "tenant_migration": {
      "type": "endpoint",
      "methods": [
        "download",
        "export_tenant",
        "import_tenant",
        "migrate_network",
        "store_token"
      ]
    },
    "tenant_migration.session": {
      "type": "endpoint",
      "methods": []
    },
    "user_groups": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get",
        "update"
      ]
    },
    "user_groups.session": {
      "type": "endpoint",
      "methods": []
    },
    "users": {
      "type": "endpoint",
      "methods": [
        "create",
        "delete",
        "get",
        "get_auth_type",
        "get_role",
        "reset",
        "update",
        "update_password"
      ]
    },
    "users.session": {
      "type": "endpoint",
      "methods": []
    }
  },
  "methods": {
    "admin_tech.delete": {
      "type": "method",
      "doc": "Deletes admin tech logs for a device.\nArgs:\n    filename: name of admin_tech file\nReturns:\n    response: http response for delete operation",
      "signature": "(filename: 'str', timeout: 'int' = 3600, interval: 'int' = 30) -> 'ManagerResponse'"
    },
    "admin_tech.download": {
      "type": "method",
      "doc": "Downloads admintech log for a device.\nArgs:\n    filename: name of admin_tech file\n    download_dir: download directory (defaults to current working directory)\nReturns:\n    path to downloaded admin_tech file",
      "signature": "(filename: 'str', download_dir: 'Optional[Path]' = None) -> 'Path'"
    },
    "admin_tech.generate": {
      "type": "method",
      "doc": "Generates admintech log for a device.\nArgs:\n    device_id: device ID (usually system-ip)\n    exclude_cores: exclude core in generated admintech log file\n    exclude_tech: exclude tech in generated admintech log file\n    exclude_logs: exclude logs in generated admintech log file\n    request_timeout: wait time in seconds to generate admintech after request\n    polling_timeout: retry period in seconds for successfull request\n    polling_interval: polling interval in seconds between request attempts\nReturns:\n    filename of generated admintech log",
      "signature": "(device_id: 'str', exclude_cores: 'bool' = True, exclude_tech: 'bool' = False, exclude_logs: 'bool' = True, request_timeout: 'int' = 3600, polling_timeout: 'int' = 1200, polling_interval: 'int' = 30) -> 'str'"
    },
    "admin_tech.get": {
      "type": "method",
      "doc": "Gets admintech log information for a device.\n\nArgs:\n    device_id: device ID (usually system-ip)\nReturns:\n    AdminTech object list for given device",
      "signature": "(device_id: 'str') -> 'List[DeviceAdminTech]'"
    },
    "admin_tech.get_all": {
      "type": "method",
      "doc": "Gets admintech log information for all devices.\n\nReturns:\n    AdminTech objects list for all devices",
      "signature": "() -> 'List[AdminTech]'"
    },
    "admin_tech.session.about": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'AboutInfo'"
    },
    "admin_tech.session.adapters.fromkeys": {
      "type": "method",
      "doc": "Create a new ordered dictionary with keys from iterable and values set to value.",
      "signature": "(iterable, value=None)"
    },
    "admin_tech.session.adapters.get": {
      "type": "method",
      "doc": "Return the value for key if key is in the dictionary, else default.",
      "signature": "(key, default=None, /)"
    },
    "admin_tech.session.adapters.move_to_end": {
      "type": "method",
      "doc": "Move an existing element to the end (or beginning if last is false).\n\nRaise KeyError if the element does not exist.",
      "signature": "(key, last=True)"
    },
    "admin_tech.session.adapters.popitem": {
      "type": "method",
      "doc": "Remove and return a (key, value) pair from the dictionary.\n\nPairs are returned in LIFO order if last is true or FIFO order if false.",
      "signature": "(last=True)"
    },
    "admin_tech.session.adapters.setdefault": {
      "type": "method",
      "doc": "Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.",
      "signature": "(key, default=None)"
    },
    "admin_tech.session.close": {
      "type": "method",
      "doc": "Closes the ManagerSession.\n\nThis method is overrided from requests.Session.\nFirstly it cleans up any resources associated with vManage.\nThen it closes all adapters and as such the session.\n\nNote: It is generally recommended to use the session as a context manager\nusing the `with` statement, which ensures that the session is properly\nclosed and resources are cleaned up even in case of exceptions.",
      "signature": "() -> 'None'"
    },
    "admin_tech.session.cookies.add_cookie_header": {
      "type": "method",
      "doc": "Add correct Cookie: header to request (urllib.request.Request object).\n\nThe Cookie2 header is also added unless policy.hide_cookie2 is true.",
      "signature": "(request)"
    },
    "admin_tech.session.cookies.clear": {
      "type": "method",
      "doc": "Clear some cookies.\n\nInvoking this method without arguments will clear all cookies.  If\ngiven a single argument, only cookies belonging to that domain will be\nremoved.  If given two arguments, cookies belonging to the specified\npath within that domain are removed.  If given three arguments, then\nthe cookie with the specified name, path and domain is removed.\n\nRaises KeyError if no matching cookie exists.",
      "signature": "(domain=None, path=None, name=None)"
    },
    "admin_tech.session.cookies.clear_expired_cookies": {
      "type": "method",
      "doc": "Discard all expired cookies.\n\nYou probably don't need to call this method: expired cookies are never\nsent back to the server (provided you're using DefaultCookiePolicy),\nthis method is called by CookieJar itself every so often, and the\n.save() method won't save expired cookies anyway (unless you ask\notherwise by passing a true ignore_expires argument).",
      "signature": "()"
    },
    "admin_tech.session.cookies.clear_session_cookies": {
      "type": "method",
      "doc": "Discard all session cookies.\n\nNote that the .save() method won't save session cookies anyway, unless\nyou ask otherwise by passing a true ignore_discard argument.",
      "signature": "()"
    },
    "admin_tech.session.cookies.copy": {
      "type": "method",
      "doc": "Return a copy of this RequestsCookieJar.",
      "signature": "()"
    },
    "admin_tech.session.cookies.extract_cookies": {
      "type": "method",
      "doc": "Extract cookies from response, where allowable given the request.",
      "signature": "(response, request)"
    },
    "admin_tech.session.cookies.get": {
      "type": "method",
      "doc": "Dict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\n.. warning:: operation is O(n), not O(1).",
      "signature": "(name, default=None, domain=None, path=None)"
    },
    "admin_tech.session.cookies.get_dict": {
      "type": "method",
      "doc": "Takes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\n:rtype: dict",
      "signature": "(domain=None, path=None)"
    },
    "admin_tech.session.cookies.get_policy": {
      "type": "method",
      "doc": "Return the CookiePolicy instance used.",
      "signature": "()"
    },
    "admin_tech.session.cookies.items": {
      "type": "method",
      "doc": "Dict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a\nvanilla python dict of key value pairs.\n\n.. seealso:: keys() and values().",
      "signature": "()"
    },
    "admin_tech.session.cookies.iteritems": {
      "type": "method",
      "doc": "Dict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\n.. seealso:: iterkeys() and itervalues().",
      "signature": "()"
    },
    "admin_tech.session.cookies.iterkeys": {
      "type": "method",
      "doc": "Dict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\n.. seealso:: itervalues() and iteritems().",
      "signature": "()"
    },
    "admin_tech.session.cookies.itervalues": {
      "type": "method",
      "doc": "Dict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\n.. seealso:: iterkeys() and iteritems().",
      "signature": "()"
    },
    "admin_tech.session.cookies.keys": {
      "type": "method",
      "doc": "Dict-like keys() that returns a list of names of cookies from the\njar.\n\n.. seealso:: values() and items().",
      "signature": "()"
    },
    "admin_tech.session.cookies.list_domains": {
      "type": "method",
      "doc": "Utility method to list all the domains in the jar.",
      "signature": "()"
    },
    "admin_tech.session.cookies.list_paths": {
      "type": "method",
      "doc": "Utility method to list all the paths in the jar.",
      "signature": "()"
    },
    "admin_tech.session.cookies.make_cookies": {
      "type": "method",
      "doc": "Return sequence of Cookie objects extracted from response object.",
      "signature": "(response, request)"
    },
    "admin_tech.session.cookies.multiple_domains": {
      "type": "method",
      "doc": "Returns True if there are multiple domains in the jar.\nReturns False otherwise.\n\n:rtype: bool",
      "signature": "()"
    },
    "admin_tech.session.cookies.pop": {
      "type": "method",
      "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised.",
      "signature": "(key, default=<object object at 0x7f336acac1e0>)"
    },
    "admin_tech.session.cookies.popitem": {
      "type": "method",
      "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair\nas a 2-tuple; but raise KeyError if D is empty.",
      "signature": "()"
    },
    "admin_tech.session.cookies.set": {
      "type": "method",
      "doc": "Dict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.",
      "signature": "(name, value, **kwargs)"
    },
    "admin_tech.session.cookies.set_cookie": {
      "type": "method",
      "doc": "Set a cookie, without checking whether or not it should be set.",
      "signature": "(cookie, *args, **kwargs)"
    },
    "admin_tech.session.cookies.set_cookie_if_ok": {
      "type": "method",
      "doc": "Set a cookie if policy says it's OK to do so.",
      "signature": "(cookie, request)"
    },
    "admin_tech.session.cookies.set_policy": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy)"
    },
    "admin_tech.session.cookies.setdefault": {
      "type": "method",
      "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D",
      "signature": "(key, default=None)"
    },
    "admin_tech.session.cookies.update": {
      "type": "method",
      "doc": "Updates this jar with cookies from another CookieJar or dict-like",
      "signature": "(other)"
    },
    "admin_tech.session.cookies.values": {
      "type": "method",
      "doc": "Dict-like values() that returns a list of values of cookies from the\njar.\n\n.. seealso:: keys() and items().",
      "signature": "()"
    },
    "admin_tech.session.delete": {
      "type": "method",
      "doc": "Sends a DELETE request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, *args, **kwargs) -> 'ManagerResponse'"
    },
    "admin_tech.session.endpoints.administration_user_and_group.create_colo_group": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.create_group_grid_columns": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.create_resource_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.create_user": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.create_user_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.create_vpn_group": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.delete_colo_group": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.delete_resource_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.delete_user": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.delete_user_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.delete_vpn_group": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.edit_colo_group": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.edit_vpn_group": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.find_resource_groups": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.find_user_auth_type": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.find_user_groups": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.find_user_groups_as_key_value": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.find_user_role": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.find_users": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.get_active_sessions": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.get_colo_groups": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.get_vpn_groups": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.remove_sessions": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.reset_user": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.resource_group_name": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.switch_resource_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_admin_password": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_password": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_profile_locale": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_profile_password": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_resource_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_user": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.update_user_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.administration_user_and_group.validate_password": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.certificate_management_device.change_vedge_list_validity": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.certificate_management_device.delete_configuration": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.certificate_management_device.generate_csr": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.certificate_management_device.generate_csr_task": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.certificate_management_device.send_to_controllers": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.certificate_management_device.send_to_vbond": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.certificate_management_vmanage.dump_certificate": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.certificate_management_vmanage.get_certificate": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.certificate_management_vmanage.get_csr": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.certificate_management_vmanage.import_certificate": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.certificate_management_vmanage.rollback": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.certificate_management_vmanage.show_info": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.client.about": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.client.server": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.client.server_ready": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.cluster_management.add_or_update_user_credentials": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.add_vmanage": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.check_if_cluster_locked": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.configure_vmanage": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.edit_vmanage": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.get_cluster_workflow_version": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.get_configured_ip_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.get_connected_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.get_connected_devices_per_tenant": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.get_tenancy_mode": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.cluster_management.get_tenants_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.get_vmanage_details": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.cluster_management.health_details": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.health_status_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.health_summary": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.is_cluster_ready": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.list_vmanages": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.node_properties": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.perform_replication_and_rebalance_of_kafka_partitions": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.remove_vmanage": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.cluster_management.set_tenancy_mode": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_dashboard_status.find_running_tasks": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_dashboard_status.find_status": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.create_filter_vpn_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.create_unique_vpn_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.create_vpn_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_change_partition_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_deactivate_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_device_action_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_install_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_reboot_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_reboot_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_rediscover_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_remove_partition_info": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.generate_security_devices_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.get_list_of_installed_devices": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.get_ztp_upgrade_config": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.get_ztp_upgrade_config_setting": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.initiate_image_download": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_amp_api_re_key": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_cancel_task": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_deactivate_smu": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_delete_amp_api_key": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_install_operation": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_lxc_activate": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_lxc_delete": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_lxc_install": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_lxc_reload": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_lxc_reset": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_lxc_upgrade": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_mark_change_partition": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_mark_default_partition": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_reboot": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_remove_partition": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_remove_software_image": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_vnf_install": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_ztp_upgrade_config": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.process_ztp_upgrade_config_setting": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.re_discover_all_device": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.re_discover_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.test_api_key": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.test_iox_config": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_actions.trigger_pending_tasks_monitoring": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.create_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.delete_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.generate_bootstrap_configuration": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.get_device_details": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.sync_devices_from_smart_account": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.unlock": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_inventory.upload_wan_edge_list": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_software_update.download_package_file": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_software_update.edit_image_metadata": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_software_update.get_image_metadata": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_software_update.get_upload_images_count": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_software_update.process_software_image": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_device_software_update.upload_software_to_manager": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_device_template.get_device_configuration_preview": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.activate": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.delete": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_details": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_disaster_recovery_local_replication_schedule": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_disaster_recovery_status": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_dr_status": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_local_history": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_reachability_info": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_remote_data_center_details": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.get_remote_data_center_version": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.pause_dr": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.register": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_disaster_recovery.unpause_dr": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.create_aaa_profile_parcel_for_system": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.create_cellular_controller_profile_parcel_for_transport": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.create_sdwan_system_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.create_sdwan_transport_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.delete_sdwan_system_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.delete_sdwan_transport_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.get_sdwan_feature_profiles": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.get_sdwan_system_aaa_parcel_schema": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.get_sdwan_system_feature_profiles": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.get_sdwan_transport_cellular_controller_parcel_schema": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_feature_profile.get_sdwan_transport_feature_profiles": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.associate": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.create_config_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.create_variables": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.delete_config_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.deploy": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.disassociate": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.edit_config_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.get": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_group.update_variables": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.create_analytics_data_file": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_banner": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_cert_configuration": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_certificates": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_claim_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_client_session_timeout": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_cloudservices": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_cloudx": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_configuration": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_configuration_by_setting_type": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_data_collection_on_notification": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_devices": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_elasticsearch_db_size": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_email_notification_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_google_map_key": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_hardware_root_cas": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_ips_signature_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_maintenance_window": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_manage_encrypted_password": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_max_sessions_per_user": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_organizations": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_password_policy": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_pnp_connect_sync": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_proxy_http_servers": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_reverse_proxies": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_sdwan_telemetry": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_server_session_timeout": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_session_life_time": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_smart_account_credentials": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_smart_licensing_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_software_install_timeout": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_sp_metadata": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_stats_config": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_vedge_cloud": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_vmanage_data_stream": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.edit_walkme": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_banner": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_cert_configuration": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_settings.get_certificates": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_claim_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_client_session_timeout": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_cloudservices": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_cloudx": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_clr_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_configuration_by_setting_type": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_data_collection_on_notification": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_devices": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_elasticsearch_db_size": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_email_notification_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_google_map_key": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_hardware_root_cas": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_ips_signature_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_maintenance_window": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_manage_encrypted_password": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_max_sessions_per_user": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_organizations": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_password_policy": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_pnp_connect_sync": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_proxy_http_servers": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_reverse_proxies": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_sdwan_telemetry": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_server_session_timeout": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_session_life_time": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_smart_account_credentials": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_smart_licensing_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_software_install_timeout": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_sp_metadata": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_stats_config": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_vedge_cloud": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_vmanage_data_stream": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.get_walkme": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_settings.new_cert_configuration": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_settings.new_configuration": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.configuration_software_actions.add_new_remote_server": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.delete_software_from_software_repository": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.get_list_of_all_images": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.get_list_of_remote_servers": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.get_remote_server": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.get_software_images": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.remove_remote_server": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.update_remote_server": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.configuration_software_actions.upload_software_from_remote_server": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.misc.get_application_protocols": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_device_details.add_tier": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.delete_tier": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.enable_sdavcon_device": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.generate_device_state_data": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.generate_device_state_data_fields": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.generate_device_state_data_with_query_string": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_all_device_status": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_counters": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_list_as_key_value": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_models": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_only_status": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_running_config": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_running_config_html": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_tloc_status": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_tloc_util": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_device_tloc_util_details": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_hardware_health_details": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_hardware_health_summary": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_stats_queues": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_sync_queues": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_tiers": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_unconfigured": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_vedge_inventory": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_vedge_inventory_summary": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.get_vmanage_system_ip": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.list_all_device_models": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.list_all_devices": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_device_details.list_all_monitor_details_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.list_currently_syncing_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.list_reachable_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.list_unreachable_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.remove_unreachable_device": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.set_block_sync": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_device_details.sync_all_devices_mem_db": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.monitoring_security_policy.get_device_list": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_server_info.get_server_info": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_status.get_disabled_device_list": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_status.get_enabled_index_for_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_status.get_statistics_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_status.update_statistics_device_list": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.monitoring_status.update_statistics_settings": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile.create_cli_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile.create_cli_full_config_parcel": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile.delete_cli_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile.delete_cli_full_config_parcel": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile.edit_cli_full_config_parcel": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sd_routing_configuration_feature_profile.get_cli_feature_profiles": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sdavc_cloud_connector.disable_cloud_connector": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.sdavc_cloud_connector.enable_cloud_connector": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.sdavc_cloud_connector.get_cloud_connector": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.sdavc_cloud_connector.get_cloud_connector_status": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.tenant_backup_restore.delete_tenant_backup": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_backup_restore.download_existing_backup_file": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_backup_restore.export_tenant_backup": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_backup_restore.import_tenant_backup": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_backup_restore.list_tenant_backup": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.create_tenant": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.create_tenant_async": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.create_tenant_async_bulk": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.delete_tenant": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.delete_tenant_async_bulk": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.force_status_collection": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.tenant_management.get_all_tenant_statuses": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.get_all_tenants": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.get_tenant": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.get_tenant_hosting_capacity_on_vsmarts": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.get_tenant_vsmart_mapping": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.switch_tenant": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.tenant_management.tenant_vsmart_mt_migrate": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.tenant_management.update_tenant": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.update_tenant_vsmart_placement": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_management.vsession_id": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.download_tenant_data": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.export_tenant_data": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.get_migration_token": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.import_tenant_data": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.import_tenant_data_with_key": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.migrate_network": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.tenant_migration.retrigger_network_migration": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.endpoints.url_monitoring.add_url_monitor": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.url_monitoring.delete_url_monitor": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.url_monitoring.get_url_monitor": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.endpoints.url_monitoring.update_url_monitor": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "admin_tech.session.get": {
      "type": "method",
      "doc": "Sends a GET request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, *args, **kwargs) -> 'ManagerResponse'"
    },
    "admin_tech.session.get_adapter": {
      "type": "method",
      "doc": "Returns the appropriate connection adapter for the given URL.\n\n:rtype: requests.adapters.BaseAdapter",
      "signature": "(url)"
    },
    "admin_tech.session.get_data": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(url: 'str') -> 'Any'"
    },
    "admin_tech.session.get_file": {
      "type": "method",
      "doc": "Get a file using session get.\n\nArgs:\n    url: dataservice api.\n    filename: Filename to write download file to.\n\nReturns:\n    http response.\n\nExample usage:\n    response = self.session.get_file(url, filename)",
      "signature": "(url: 'str', filename: 'Path') -> 'Response'"
    },
    "admin_tech.session.get_full_url": {
      "type": "method",
      "doc": "Returns base API url plus given url path.",
      "signature": "(url_path: 'str') -> 'str'"
    },
    "admin_tech.session.get_json": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(url: 'str') -> 'Any'"
    },
    "admin_tech.session.get_redirect_target": {
      "type": "method",
      "doc": "Receives a Response. Returns a redirect URI or ``None``",
      "signature": "(resp)"
    },
    "admin_tech.session.get_tenant_id": {
      "type": "method",
      "doc": "Gets tenant UUID for its subdomain.\n\nReturns:\n    Tenant UUID.",
      "signature": "() -> 'str'"
    },
    "admin_tech.session.head": {
      "type": "method",
      "doc": "Sends a HEAD request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, **kwargs)"
    },
    "admin_tech.session.headers.clear": {
      "type": "method",
      "doc": "D.clear() -> None.  Remove all items from D.",
      "signature": "()"
    },
    "admin_tech.session.headers.copy": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.headers.get": {
      "type": "method",
      "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
      "signature": "(key, default=None)"
    },
    "admin_tech.session.headers.items": {
      "type": "method",
      "doc": "D.items() -> a set-like object providing a view on D's items",
      "signature": "()"
    },
    "admin_tech.session.headers.keys": {
      "type": "method",
      "doc": "D.keys() -> a set-like object providing a view on D's keys",
      "signature": "()"
    },
    "admin_tech.session.headers.lower_items": {
      "type": "method",
      "doc": "Like iteritems(), but with all lowercase keys.",
      "signature": "()"
    },
    "admin_tech.session.headers.pop": {
      "type": "method",
      "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised.",
      "signature": "(key, default=<object object at 0x7f336acac1e0>)"
    },
    "admin_tech.session.headers.popitem": {
      "type": "method",
      "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair\nas a 2-tuple; but raise KeyError if D is empty.",
      "signature": "()"
    },
    "admin_tech.session.headers.setdefault": {
      "type": "method",
      "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D",
      "signature": "(key, default=None)"
    },
    "admin_tech.session.headers.update": {
      "type": "method",
      "doc": "D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\nIf E present and has a .keys() method, does:     for k in E: D[k] = E[k]\nIf E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\nIn either case, this is followed by: for k, v in F.items(): D[k] = v",
      "signature": "(other=(), /, **kwds)"
    },
    "admin_tech.session.headers.values": {
      "type": "method",
      "doc": "D.values() -> an object providing a view on D's values",
      "signature": "()"
    },
    "admin_tech.session.logger.addFilter": {
      "type": "method",
      "doc": "Add the specified filter to this handler.",
      "signature": "(filter)"
    },
    "admin_tech.session.logger.addHandler": {
      "type": "method",
      "doc": "Add the specified handler to this logger.",
      "signature": "(hdlr)"
    },
    "admin_tech.session.logger.callHandlers": {
      "type": "method",
      "doc": "Pass a record to all relevant handlers.\n\nLoop through all handlers for this logger and its parents in the\nlogger hierarchy. If no handler was found, output a one-off error\nmessage to sys.stderr. Stop searching up the hierarchy whenever a\nlogger with the \"propagate\" attribute set to zero is found - that\nwill be the last logger whose handlers are called.",
      "signature": "(record)"
    },
    "admin_tech.session.logger.critical": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'CRITICAL'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.critical(\"Houston, we have a %s\", \"major disaster\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.debug": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'DEBUG'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.error": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'ERROR'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.error(\"Houston, we have a %s\", \"major problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.exception": {
      "type": "method",
      "doc": "Convenience method for logging an ERROR with exception information.",
      "signature": "(msg, *args, exc_info=True, **kwargs)"
    },
    "admin_tech.session.logger.fatal": {
      "type": "method",
      "doc": "Don't use this method, use critical() instead.",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.filter": {
      "type": "method",
      "doc": "Determine if a record is loggable by consulting all the filters.\n\nThe default is to allow the record to be logged; any filter can veto\nthis by returning a false value.\nIf a filter attached to a handler returns a log record instance,\nthen that instance is used in place of the original log record in\nany further processing of the event by that handler.\nIf a filter returns any other true value, the original log record\nis used in any further processing of the event by that handler.\n\nIf none of the filters return false values, this method returns\na log record.\nIf any of the filters return a false value, this method returns\na false value.\n\n.. versionchanged:: 3.2\n\n   Allow filters to be just callables.\n\n.. versionchanged:: 3.12\n   Allow filters to return a LogRecord instead of\n   modifying it in place.",
      "signature": "(record)"
    },
    "admin_tech.session.logger.findCaller": {
      "type": "method",
      "doc": "Find the stack frame of the caller so that we can note the source\nfile name, line number and function name.",
      "signature": "(stack_info=False, stacklevel=1)"
    },
    "admin_tech.session.logger.getChild": {
      "type": "method",
      "doc": "Get a logger which is a descendant to this one.\n\nThis is a convenience method, such that\n\nlogging.getLogger('abc').getChild('def.ghi')\n\nis the same as\n\nlogging.getLogger('abc.def.ghi')\n\nIt's useful, for example, when the parent logger is named using\n__name__ rather than a literal string.",
      "signature": "(suffix)"
    },
    "admin_tech.session.logger.getChildren": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.logger.getEffectiveLevel": {
      "type": "method",
      "doc": "Get the effective level for this logger.\n\nLoop through this logger and its parents in the logger hierarchy,\nlooking for a non-zero logging level. Return the first one found.",
      "signature": "()"
    },
    "admin_tech.session.logger.handle": {
      "type": "method",
      "doc": "Call the handlers for the specified record.\n\nThis method is used for unpickled records received from a socket, as\nwell as those created locally. Logger-level filtering is applied.",
      "signature": "(record)"
    },
    "admin_tech.session.logger.hasHandlers": {
      "type": "method",
      "doc": "See if this logger has any handlers configured.\n\nLoop through all handlers for this logger and its parents in the\nlogger hierarchy. Return True if a handler was found, else False.\nStop searching up the hierarchy whenever a logger with the \"propagate\"\nattribute set to zero is found - that will be the last logger which\nis checked for the existence of handlers.",
      "signature": "()"
    },
    "admin_tech.session.logger.info": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'INFO'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.info(\"Houston, we have a %s\", \"notable problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.isEnabledFor": {
      "type": "method",
      "doc": "Is this logger enabled for level 'level'?",
      "signature": "(level)"
    },
    "admin_tech.session.logger.log": {
      "type": "method",
      "doc": "Log 'msg % args' with the integer severity 'level'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=True)",
      "signature": "(level, msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.makeRecord": {
      "type": "method",
      "doc": "A factory method which can be overridden in subclasses to create\nspecialized LogRecords.",
      "signature": "(name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)"
    },
    "admin_tech.session.logger.manager.getLogger": {
      "type": "method",
      "doc": "Get a logger with the specified name (channel name), creating it\nif it doesn't yet exist. This name is a dot-separated hierarchical\nname, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\nIf a PlaceHolder existed for the specified name [i.e. the logger\ndidn't exist but a child of it did], replace it with the created\nlogger and fix up the parent/child references which pointed to the\nplaceholder to now point to the logger.",
      "signature": "(name)"
    },
    "admin_tech.session.logger.manager.setLogRecordFactory": {
      "type": "method",
      "doc": "Set the factory to be used when instantiating a log record with this\nManager.",
      "signature": "(factory)"
    },
    "admin_tech.session.logger.manager.setLoggerClass": {
      "type": "method",
      "doc": "Set the class to be used when instantiating a logger with this Manager.",
      "signature": "(klass)"
    },
    "admin_tech.session.logger.parent.addFilter": {
      "type": "method",
      "doc": "Add the specified filter to this handler.",
      "signature": "(filter)"
    },
    "admin_tech.session.logger.parent.addHandler": {
      "type": "method",
      "doc": "Add the specified handler to this logger.",
      "signature": "(hdlr)"
    },
    "admin_tech.session.logger.parent.callHandlers": {
      "type": "method",
      "doc": "Pass a record to all relevant handlers.\n\nLoop through all handlers for this logger and its parents in the\nlogger hierarchy. If no handler was found, output a one-off error\nmessage to sys.stderr. Stop searching up the hierarchy whenever a\nlogger with the \"propagate\" attribute set to zero is found - that\nwill be the last logger whose handlers are called.",
      "signature": "(record)"
    },
    "admin_tech.session.logger.parent.critical": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'CRITICAL'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.critical(\"Houston, we have a %s\", \"major disaster\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.debug": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'DEBUG'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.error": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'ERROR'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.error(\"Houston, we have a %s\", \"major problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.exception": {
      "type": "method",
      "doc": "Convenience method for logging an ERROR with exception information.",
      "signature": "(msg, *args, exc_info=True, **kwargs)"
    },
    "admin_tech.session.logger.parent.fatal": {
      "type": "method",
      "doc": "Don't use this method, use critical() instead.",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.filter": {
      "type": "method",
      "doc": "Determine if a record is loggable by consulting all the filters.\n\nThe default is to allow the record to be logged; any filter can veto\nthis by returning a false value.\nIf a filter attached to a handler returns a log record instance,\nthen that instance is used in place of the original log record in\nany further processing of the event by that handler.\nIf a filter returns any other true value, the original log record\nis used in any further processing of the event by that handler.\n\nIf none of the filters return false values, this method returns\na log record.\nIf any of the filters return a false value, this method returns\na false value.\n\n.. versionchanged:: 3.2\n\n   Allow filters to be just callables.\n\n.. versionchanged:: 3.12\n   Allow filters to return a LogRecord instead of\n   modifying it in place.",
      "signature": "(record)"
    },
    "admin_tech.session.logger.parent.findCaller": {
      "type": "method",
      "doc": "Find the stack frame of the caller so that we can note the source\nfile name, line number and function name.",
      "signature": "(stack_info=False, stacklevel=1)"
    },
    "admin_tech.session.logger.parent.getChild": {
      "type": "method",
      "doc": "Get a logger which is a descendant to this one.\n\nThis is a convenience method, such that\n\nlogging.getLogger('abc').getChild('def.ghi')\n\nis the same as\n\nlogging.getLogger('abc.def.ghi')\n\nIt's useful, for example, when the parent logger is named using\n__name__ rather than a literal string.",
      "signature": "(suffix)"
    },
    "admin_tech.session.logger.parent.getChildren": {
      "type": "method",
      "doc": "No documentation",
      "signature": "()"
    },
    "admin_tech.session.logger.parent.getEffectiveLevel": {
      "type": "method",
      "doc": "Get the effective level for this logger.\n\nLoop through this logger and its parents in the logger hierarchy,\nlooking for a non-zero logging level. Return the first one found.",
      "signature": "()"
    },
    "admin_tech.session.logger.parent.handle": {
      "type": "method",
      "doc": "Call the handlers for the specified record.\n\nThis method is used for unpickled records received from a socket, as\nwell as those created locally. Logger-level filtering is applied.",
      "signature": "(record)"
    },
    "admin_tech.session.logger.parent.hasHandlers": {
      "type": "method",
      "doc": "See if this logger has any handlers configured.\n\nLoop through all handlers for this logger and its parents in the\nlogger hierarchy. Return True if a handler was found, else False.\nStop searching up the hierarchy whenever a logger with the \"propagate\"\nattribute set to zero is found - that will be the last logger which\nis checked for the existence of handlers.",
      "signature": "()"
    },
    "admin_tech.session.logger.parent.info": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'INFO'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.info(\"Houston, we have a %s\", \"notable problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.isEnabledFor": {
      "type": "method",
      "doc": "Is this logger enabled for level 'level'?",
      "signature": "(level)"
    },
    "admin_tech.session.logger.parent.log": {
      "type": "method",
      "doc": "Log 'msg % args' with the integer severity 'level'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=True)",
      "signature": "(level, msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.makeRecord": {
      "type": "method",
      "doc": "A factory method which can be overridden in subclasses to create\nspecialized LogRecords.",
      "signature": "(name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)"
    },
    "admin_tech.session.logger.parent.removeFilter": {
      "type": "method",
      "doc": "Remove the specified filter from this handler.",
      "signature": "(filter)"
    },
    "admin_tech.session.logger.parent.removeHandler": {
      "type": "method",
      "doc": "Remove the specified handler from this logger.",
      "signature": "(hdlr)"
    },
    "admin_tech.session.logger.parent.setLevel": {
      "type": "method",
      "doc": "Set the logging level of this logger.  level must be an int or a str.",
      "signature": "(level)"
    },
    "admin_tech.session.logger.parent.warn": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.parent.warning": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'WARNING'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.removeFilter": {
      "type": "method",
      "doc": "Remove the specified filter from this handler.",
      "signature": "(filter)"
    },
    "admin_tech.session.logger.removeHandler": {
      "type": "method",
      "doc": "Remove the specified handler from this logger.",
      "signature": "(hdlr)"
    },
    "admin_tech.session.logger.setLevel": {
      "type": "method",
      "doc": "Set the logging level of this logger.  level must be an int or a str.",
      "signature": "(level)"
    },
    "admin_tech.session.logger.warn": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.logger.warning": {
      "type": "method",
      "doc": "Log 'msg % args' with severity 'WARNING'.\n\nTo pass exception information, use the keyword argument exc_info with\na true value, e.g.\n\nlogger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=True)",
      "signature": "(msg, *args, **kwargs)"
    },
    "admin_tech.session.login": {
      "type": "method",
      "doc": "Performs login to SDWAN Manager and fetches important server info to instance variables\n\nRaises:\n    SessionNotCreatedError: indicates session configuration is not consistent\n\nReturns:\n    ManagerSession: (self)",
      "signature": "() -> 'ManagerSession'"
    },
    "admin_tech.session.logout": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'None'"
    },
    "admin_tech.session.merge_environment_settings": {
      "type": "method",
      "doc": "Check the environment and merge it with some settings.\n\n:rtype: dict",
      "signature": "(url, proxies, stream, verify, cert)"
    },
    "admin_tech.session.mount": {
      "type": "method",
      "doc": "Registers a connection adapter to a prefix.\n\nAdapters are sorted in descending order by prefix length.",
      "signature": "(prefix, adapter)"
    },
    "admin_tech.session.options": {
      "type": "method",
      "doc": "Sends a OPTIONS request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, **kwargs)"
    },
    "admin_tech.session.patch": {
      "type": "method",
      "doc": "Sends a PATCH request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, data=None, **kwargs)"
    },
    "admin_tech.session.post": {
      "type": "method",
      "doc": "Sends a POST request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) json to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, *args, **kwargs) -> 'ManagerResponse'"
    },
    "admin_tech.session.prepare_request": {
      "type": "method",
      "doc": "Constructs a :class:`PreparedRequest <PreparedRequest>` for\ntransmission and returns it. The :class:`PreparedRequest` has settings\nmerged from the :class:`Request <Request>` instance and those of the\n:class:`Session`.\n\n:param request: :class:`Request` instance to prepare with this\n    session's settings.\n:rtype: requests.PreparedRequest",
      "signature": "(request)"
    },
    "admin_tech.session.put": {
      "type": "method",
      "doc": "Sends a PUT request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
      "signature": "(url, *args, **kwargs) -> 'ManagerResponse'"
    },
    "admin_tech.session.rebuild_auth": {
      "type": "method",
      "doc": "When being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss.",
      "signature": "(prepared_request, response)"
    },
    "admin_tech.session.rebuild_method": {
      "type": "method",
      "doc": "When being redirected we may want to change the method of the request\nbased on certain specs or browser behavior.",
      "signature": "(prepared_request, response)"
    },
    "admin_tech.session.rebuild_proxies": {
      "type": "method",
      "doc": "This method re-evaluates the proxy configuration by considering the\nenvironment variables. If we are redirected to a URL covered by\nNO_PROXY, we strip the proxy configuration. Otherwise, we set missing\nproxy keys for this URL (in case they were stripped by a previous\nredirect).\n\nThis method also replaces the Proxy-Authorization header where\nnecessary.\n\n:rtype: dict",
      "signature": "(prepared_request, proxies)"
    },
    "admin_tech.session.request": {
      "type": "method",
      "doc": "Constructs a :class:`Request <Request>`, prepares it and sends it.\nReturns :class:`Response <Response>` object.\n\n:param method: method for the new :class:`Request` object.\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary or bytes to be sent in the query\n    string for the :class:`Request`.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) json to send in the body of the\n    :class:`Request`.\n:param headers: (optional) Dictionary of HTTP Headers to send with the\n    :class:`Request`.\n:param cookies: (optional) Dict or CookieJar object to send with the\n    :class:`Request`.\n:param files: (optional) Dictionary of ``'filename': file-like-objects``\n    for multipart encoding upload.\n:param auth: (optional) Auth tuple or callable to enable\n    Basic/Digest/Custom HTTP Auth.\n:param timeout: (optional) How long to wait for the server to send\n    data before giving up, as a float, or a :ref:`(connect timeout,\n    read timeout) <timeouts>` tuple.\n:type timeout: float or tuple\n:param allow_redirects: (optional) Set to True by default.\n:type allow_redirects: bool\n:param proxies: (optional) Dictionary mapping protocol or protocol and\n    hostname to the URL of the proxy.\n:param hooks: (optional) Dictionary mapping hook name to one event or\n    list of events, event must be callable.\n:param stream: (optional) whether to immediately download the response\n    content. Defaults to ``False``.\n:param verify: (optional) Either a boolean, in which case it controls whether we verify\n    the server's TLS certificate, or a string, in which case it must be a path\n    to a CA bundle to use. Defaults to ``True``. When set to\n    ``False``, requests will accept any TLS certificate presented by\n    the server, and will ignore hostname mismatches and/or expired\n    certificates, which will make your application vulnerable to\n    man-in-the-middle (MitM) attacks. Setting verify to ``False``\n    may be useful during local development or testing.\n:param cert: (optional) if String, path to ssl client cert file (.pem).\n    If Tuple, ('cert', 'key') pair.\n:rtype: requests.Response",
      "signature": "(method, url, *args, **kwargs) -> 'ManagerResponse'"
    },
    "admin_tech.session.resolve_redirects": {
      "type": "method",
      "doc": "Receives a Response. Returns a generator of Responses or Requests.",
      "signature": "(resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None, yield_requests=False, **adapter_kwargs)"
    },
    "admin_tech.session.response_trace": {
      "type": "method",
      "doc": "Returns human readable string containing Request-Response history contents for given response.\n\nArgs:\n    response: Response object to be debugged (note it contains an PreparedRequest object already)\n    request: optional Request object to be debugged (considered to be latest request)\n\nWhen response is provided, request argument is ignored and contents of reqest.response will be returned.\n\nReturns:\n    str",
      "signature": "(response: Optional[requests.models.Response], request: Union[requests.models.Request, requests.models.PreparedRequest, NoneType]) -> str"
    },
    "admin_tech.session.restart_imminent": {
      "type": "method",
      "doc": "Notify session that restart is imminent.\nConnectionError and status code 503 will cause session to wait for connectivity and perform login again\n\nArgs:\n    restart_timeout_override (Optional[int], optional): override session property which controls restart timeout",
      "signature": "(restart_timeout_override: 'Optional[int]' = None)"
    },
    "admin_tech.session.send": {
      "type": "method",
      "doc": "Send a given PreparedRequest.\n\n:rtype: requests.Response",
      "signature": "(request, **kwargs)"
    },
    "admin_tech.session.server": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'ServerInfo'"
    },
    "admin_tech.session.should_strip_auth": {
      "type": "method",
      "doc": "Decide whether Authorization header should be removed when redirecting",
      "signature": "(old_url, new_url)"
    },
    "admin_tech.session.wait_server_ready": {
      "type": "method",
      "doc": "Waits until server is ready for API requests with given timeout in seconds",
      "signature": "(timeout: 'int', poll_period: 'int' = 10) -> 'None'"
    },
    "administration_settings.disable_sdavc_cloud_connector": {
      "type": "method",
      "doc": "Disables SD-AVC Cloud Connector on vManage.",
      "signature": "() -> 'bool'"
    },
    "administration_settings.enable_cloud_on_ramp_for_saas_mode": {
      "type": "method",
      "doc": "Enable or disable COR for SaaS",
      "signature": "(disable=False)"
    },
    "administration_settings.enable_sdavc_cloud_connector": {
      "type": "method",
      "doc": "Enables SD-AVC Cloud Connector on vManage.",
      "signature": "(cloud_connector: 'CloudConnectorData') -> 'bool'"
    },
    "administration_settings.get_cloud_on_ramp_for_saas_mode": {
      "type": "method",
      "doc": "Get information about Cloud on Ramp for Saas mode",
      "signature": "()"
    },
    "administration_settings.get_cloud_services": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'CloudServicesSettings'"
    },
    "administration_settings.get_organization": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'Organization'"
    },
    "administration_settings.get_sdavc_cloud_connector_config": {
      "type": "method",
      "doc": "Gets SD-AVC Cloud Connector Config.\n\nReturns:\n    CloudConnector dataclass config",
      "signature": "() -> 'CloudConnectorData'"
    },
    "administration_settings.get_software_install_timeout": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'SoftwareInstallTimeout'"
    },
    "administration_settings.set_cloud_services": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(config: 'CloudServicesSettings') -> 'bool'"
    },
    "administration_settings.set_software_install_timeout": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(download_timeout_min: 'int', activate_timeout_min: 'int')"
    },
    "administration_settings.update": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(payload: 'Union[Organization, Certificate, Password, Vbond]') -> 'bool'"
    },
    "alarms.check_alarms": {
      "type": "method",
      "doc": "Checks if alarms have occurred.\n\nFor a specified period of time, the method queries the API about unread alarms and\nchecks if they occur in the expected ones. If all alarms occur before the time expires,\nit will not poll any further.\n\nArgs:\n  expected(list): The list of expected alarms.\n  timeout_seconds (int): Failure timeout.\n  sleep_seconds (int): Sleep time.\n\nReturns:\n  The dictionary with alarms that occurred (key 'found') and did not (key 'no-found')\n\nExamples:\n    >>> expected_alarms = [{\n        \"type\": \"memory-usage\",\n        \"rulename\": \"memory-usage\",\n        \"component\": \"System\",\n        \"severity\": \"Medium\",\n        \"system_ip\": \"192.168.1.2\",\n        \"acknowledged\": true,\n        \"active\": true,\n        }]\n    >>> result = AlarmsAPI(session).check_alarms(expected = expected_alarms)",
      "signature": "(expected: 'List[Dict[str, str]]', timeout_seconds: 'int' = 240, sleep_seconds: 'int' = 5) -> 'Dict[str, set]'"
    },
    "alarms.get": {
      "type": "method",
      "doc": "Data sequence of alarms.\n\nArgs:\n    from_time: Gets alarms from time in hour. Defaults to None - gets all alrams.\n\nReturns:\n    DataSequence[AlarmData] of getted alarms.\n\nExamples:\n    Get all alarms:\n    >>> alarms = AlarmsAPI(session).get()\n\n    Get all alarms from 3 hours:\n    >>> alarms = AlarmsAPI(session).get(from_time=3)\n\n    Get all not viewed alarms:\n    >>> alarms = AlarmsAPI(session).get()\n    >>> not_viewed_alarms = alarms.filter(viewed=False)\n\n    Get all critical alarms:\n    >>> alarms = AlarmsAPI(session).get()\n    >>> critical_alarms = alarms.filter(severity=Severity.CRITICAL)",
      "signature": "(from_time: 'Optional[int]' = None) -> 'DataSequence[AlarmData]'"
    },
    "alarms.mark_all_as_viewed": {
      "type": "method",
      "doc": "Marks all alarms as viewed.",
      "signature": "() -> 'None'"
    },
    "cluster_management.get_cluster_management_health_status": {
      "type": "method",
      "doc": "Gets Cluster Management Service Reachability health status.\n\nReturns:\n    TODO return health status dataclass",
      "signature": "() -> 'Union[dict, list]'"
    },
    "cluster_management.modify_cluster_setup": {
      "type": "method",
      "doc": "Updates vManage cluster configuration.\n\nArgs:\n    service_configuration: vManage cluster config",
      "signature": "(service_configuration: 'ServiceConfigurationData') -> 'bool'"
    },
    "config_device_inventory_api.endpoint.create_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.endpoint.delete_device": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.endpoint.generate_bootstrap_configuration": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.endpoint.get_device_details": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.endpoint.sync_devices_from_smart_account": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.endpoint.unlock": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.endpoint.upload_wan_edge_list": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_device_inventory_api.generate_bootstrap_cfg": {
      "type": "method",
      "doc": "Returns handy model of generated bootstrap config",
      "signature": "(device_uuid: 'UUID', configtype: 'ConfigType' = 'cloudinit', incl_def_root_cert: 'bool' = False, version: 'str' = 'v1') -> 'BoostrapConfigurationDetails'"
    },
    "config_device_inventory_api.unlock": {
      "type": "method",
      "doc": "Unlocks device from config-group",
      "signature": "(device_uuid: 'str', device_type: 'str', device_details: 'list') -> 'Task'"
    },
    "config_group.associate": {
      "type": "method",
      "doc": "Associates given config-group to specified list of devices",
      "signature": "(cg_id: 'str', device_ids: 'list') -> 'None'"
    },
    "config_group.create": {
      "type": "method",
      "doc": "Creates new config-group",
      "signature": "(name: 'str', description: 'str', solution: 'Solution', profile_ids: 'list') -> 'ConfigGroupCreationResponse'"
    },
    "config_group.create_variables": {
      "type": "method",
      "doc": "Creates device specific variable data in given config-group",
      "signature": "(cg_id: 'str', device_ids: 'list', suggestions: 'bool' = True) -> 'ConfigGroupVariablesCreateResponse'"
    },
    "config_group.delete": {
      "type": "method",
      "doc": "Deletes existing config-group with given ID",
      "signature": "(cg_id: 'str') -> 'None'"
    },
    "config_group.deploy": {
      "type": "method",
      "doc": "Deploys specified config-group config to given list of devices",
      "signature": "(cg_id: 'str', device_ids: 'list') -> 'ConfigGroupDeployResponse'"
    },
    "config_group.disassociate": {
      "type": "method",
      "doc": "Disassociates given list of devices from the specified config-group",
      "signature": "(cg_id: 'str', device_ids: 'list') -> 'ConfigGroupDisassociateResponse'"
    },
    "config_group.edit": {
      "type": "method",
      "doc": "Modifies feature profiles in existing config-group",
      "signature": "(cg_id: 'str', name: 'str', description: 'str', solution: 'Solution', profile_ids: 'list') -> 'ConfigGroupEditResponse'"
    },
    "config_group.endpoint.associate": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.create_config_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.create_variables": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.delete_config_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.deploy": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.disassociate": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.edit_config_group": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.get": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.endpoint.update_variables": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "config_group.get": {
      "type": "method",
      "doc": "Gets list of existing config-groups",
      "signature": "() -> 'ConfigGroupResponsePayload'"
    },
    "config_group.update_variables": {
      "type": "method",
      "doc": "Updates device specific variable data in given config-group",
      "signature": "(cg_id: 'str', solution: 'Solution', device_variables: 'list') -> 'None'"
    },
    "dashboard.get_bfd_connectivity_count": {
      "type": "method",
      "doc": "Get information about bfd connectivity count.\n\nReturns:\n    DataSequance of Count dataclass with bfd connectivity",
      "signature": "() -> 'DataSequence[Count]'"
    },
    "dashboard.get_certificates_status": {
      "type": "method",
      "doc": "Get information about status of certificates.\n\nReturns:\n    DataSequance of CertificatesStatus dataclass with devices",
      "signature": "() -> 'DataSequence[CertificatesStatus]'"
    },
    "dashboard.get_control_statuses_count": {
      "type": "method",
      "doc": "Get information about control statuses.\n\nReturns:\n    DataSequance of Count dataclass with control statuses",
      "signature": "() -> 'DataSequence[Count]'"
    },
    "dashboard.get_devices_count": {
      "type": "method",
      "doc": "Get information about number of devices (does not include vManages).\n\nReturns:\n    DataSequance of Count dataclass with devices",
      "signature": "() -> 'DataSequence[Count]'"
    },
    "dashboard.get_devices_health": {
      "type": "method",
      "doc": "Get information about devices health\n\nReturns:\n    DevicesHealth object",
      "signature": "() -> 'DevicesHealth'"
    },
    "dashboard.get_devices_health_overview": {
      "type": "method",
      "doc": "Get information about health overview devices.\n\nReturns:\n    DataSequance of DeviceHealthOverview dataclass with health information.",
      "signature": "() -> 'DataSequence[DeviceHealthOverview]'"
    },
    "dashboard.get_edges_inventory_count": {
      "type": "method",
      "doc": "Get information about edges inventory.\n\nReturns:\n    DataSequance of Count dataclass with edges inventory count",
      "signature": "() -> 'DataSequence[Count]'"
    },
    "dashboard.get_licensed_devices": {
      "type": "method",
      "doc": "Get information about licensed devices.\n\nReturns:\n    DataSequance of LicensedDevices dataclass with licences information.",
      "signature": "() -> 'DataSequence[LicensedDevices]'"
    },
    "dashboard.get_tenant_status": {
      "type": "method",
      "doc": "Get information about tenant status, including:\n- control status\n- site health\n- vEdge health\n- vSmart status\n\nReturns:\n    DataSequance of TenantStatus dataclass with tenant status information",
      "signature": "() -> 'DataSequence[TenantStatus]'"
    },
    "dashboard.get_transport_health": {
      "type": "method",
      "doc": "Get information about loss percentage, latency and jitter for all links and combinations of colors.\n\nReturns:\n    DataSequance of TransportHealth dataclass with loss percentage, latency and jitter information.",
      "signature": "() -> 'DataSequence[TransportHealth]'"
    },
    "dashboard.get_transport_interface_distribution": {
      "type": "method",
      "doc": "Get information about transport interface distribution.\n\nReturns:\n    DataSequance of Count dataclass with transport interface distribution",
      "signature": "() -> 'DataSequence[Count]'"
    },
    "dashboard.get_tunnel_health": {
      "type": "method",
      "doc": "Get information about state, loss percentage, latency and jitter for tunnels.\n\nReturns:\n    DataSequance of TunnelHealth dataclass with tunnel health information.",
      "signature": "() -> 'DataSequence[TunnelHealth]'"
    },
    "dashboard.get_vmanages_count": {
      "type": "method",
      "doc": "Get information about number of vmanages.\n\nReturns:\n    DataSequance of Count dataclass with vManages",
      "signature": "() -> 'DataSequence[Count]'"
    },
    "device_state.enable_data_stream": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'Iterator'"
    },
    "device_state.get_bfd_sessions": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(device_id: 'str') -> 'List[BfdSessionData]'"
    },
    "device_state.get_colors": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(device_id: 'str') -> 'List[str]'"
    },
    "device_state.get_device_control_connections_info": {
      "type": "method",
      "doc": "Gets control connections for a device.\n\nArgs:\n    device_id: device ID (usually system-ip)\n\nReturns:\n    list of Connection objects",
      "signature": "(device_id) -> 'List[Connection]'"
    },
    "device_state.get_device_crash_info": {
      "type": "method",
      "doc": "Gets crash info for a device.\n\nArgs:\n     device_id: device ID (usually system-ip)\n\nReturns:\n    Union[list, dict]: list of dicts (FIXME: add mapping to a NamedTuples)",
      "signature": "(device_id: 'str') -> 'Union[list, dict]'"
    },
    "device_state.get_device_orchestrator_connections_info": {
      "type": "method",
      "doc": "Gets orchestrator connections for a device\n\nArgs:\n    device_id: device ID (usually system-ip)\n\nReturns:\n    list of Connection objects",
      "signature": "(device_id) -> 'List[Connection]'"
    },
    "device_state.get_device_reboot_history": {
      "type": "method",
      "doc": "Gets device reboots list.\n\nArgs:\n    device_id: device ID (usually system-ip)\n\nReturns:\n    list of Reboot objects",
      "signature": "(device_id) -> 'DataSequence[RebootEntry]'"
    },
    "device_state.get_device_wan_interfaces": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(device_id: 'str')"
    },
    "device_state.get_system_status": {
      "type": "method",
      "doc": "Get system information for a device.\n\nArgs:\n    device_id: device ID (usually system-ip)\n\nReturns:\n   Device object",
      "signature": "(device_id: 'str') -> 'Device'"
    },
    "device_state.wait_for_bfd_session_up": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(system_ip: 'str', sleep_seconds: 'int' = 5, timeout_seconds: 'int' = 60, exp_state: 'str' = 'up')"
    },
    "device_state.wait_for_device_state": {
      "type": "method",
      "doc": "Waiting for the state of the machine.\n\nArgs:\n  device_id(Str): Device ID (usually system-ip)\n  timeout_seconds(int): Failure timeout.\n  sleep_seconds(int): Sleep time.\n  exp_state(Reachability): The expected state of the machine\n\nReturns:\n  True if the expected state has been achieved",
      "signature": "(device_id: 'str', sleep_seconds: 'int' = 5, timeout_seconds: 'int' = 600, exp_state: 'Reachability' = <Reachability.REACHABLE: 'reachable'>)"
    },
    "devices.count_devices": {
      "type": "method",
      "doc": "Gets number of devices of given personality.\n\nArgs:\n    personality: personality of the device\n\nReturns:\n    count of devices",
      "signature": "(personality: 'Personality') -> 'int'"
    },
    "devices.get": {
      "type": "method",
      "doc": "Data sequence of all devices.\n\nArgs:\n    rediscover: Rediscover device request payload\n\nReturns:\n    DataSequence[Device] of all devices\n\n## Examples:\n\nGet all vManages:\n>>> devices = DevicesAPI(session).get()\n>>> vManages = devices.filter(personality=Personality.VMANAGE)",
      "signature": "(rediscover: 'bool' = False) -> 'DataSequence[Device]'"
    },
    "devices.get_device_details": {
      "type": "method",
      "doc": "Gets system information for a device.\n\nArgs:\n    device_id: device ID (usually system-ip)\n\nReturns:\n    Device object",
      "signature": "(uuid: 'str') -> 'Device'"
    },
    "devices.get_reachable_devices": {
      "type": "method",
      "doc": "Get reachable devices by personality.\n\nArgs:\n    personality: personality of the device\n\nReturns:\n    reachable devices",
      "signature": "(personality: 'Personality') -> 'DataSequence[Device]'"
    },
    "devices.get_system_ip_based_on_local_system_ip": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(local_system_ip) -> 'str'"
    },
    "devices.send_certificate_state_to_controllers": {
      "type": "method",
      "doc": "Sending the current status of certificates to the controllers\n\nReturns:\n    bool: True if all ok, False like something wrong",
      "signature": "(sleep_seconds: 'int' = 5, timeout_seconds: 'int' = 600) -> 'bool'"
    },
    "logs.get_auditlogs": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(file_path: 'Optional[str]' = None, n_hours: 'int' = 1) -> 'None'"
    },
    "lxcsoftware.device_versions.get_device_available": {
      "type": "method",
      "doc": "Create devices payload list included requested, if requested version\nis in available versions\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\n\nReturns:\n    list : list of devices",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "lxcsoftware.device_versions.get_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'List[PartitionDevice]'"
    },
    "lxcsoftware.device_versions.get_device_list_in_installed": {
      "type": "method",
      "doc": "Create devices payload list included requested version, if requested version\nis in installed versions\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "lxcsoftware.device_versions.get_devices_available_versions": {
      "type": "method",
      "doc": "Create devices payload list included available software versions key\nfor every device in devices list\n\nArgs:\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "lxcsoftware.device_versions.get_devices_current_version": {
      "type": "method",
      "doc": "Create devices payload list included current software version key\nfor every device in devices list\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "lxcsoftware.device_versions.get_lxcactivate_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[LxcActivateDevice]'"
    },
    "lxcsoftware.device_versions.get_lxcupgrade_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[LxcUpgradeDevice]'"
    },
    "lxcsoftware.device_versions.repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "lxcsoftware.device_versions.repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "lxcsoftware.device_versions.repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "lxcsoftware.device_versions.repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "lxcsoftware.device_versions.repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "lxcsoftware.device_versions.repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "lxcsoftware.device_versions.repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "lxcsoftware.lxcactivate": {
      "type": "method",
      "doc": "Requires that selected devices have already version_to_activate installed(upgraded)\n\nArgs:\n    devices (List[DeviceDetailsResponse]): For those devices software will be activated\n    version_to_activate (Optional[str]): version to be set as current version\n\n    Notice: Have to pass one of those arguments (version_to_activate, image)\n\nRaises:\n    EmptyVersionPayloadError: If selected version_to_activate or image not detected in available files\n\nReturns:\n    str: Activate software action id",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', version_to_activate: 'str') -> 'Task'"
    },
    "lxcsoftware.lxcdelete": {
      "type": "method",
      "doc": "Requires that selected devices have already version_to_delete\n\nArgs:\n    devices (List[DeviceDetailsResponse]): For those devices lxc software will be deleted\n    version_to_delete (Optional[str]): version to delete\n\n    Notice: Have to pass one of those arguments (version_to_delete)\n\nRaises:\n    EmptyVersionPayloadError: If selected version_to_activate or image not detected in available files\n\nReturns:\n    str: Delete software action id",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', version_to_delete: 'str') -> 'Task'"
    },
    "lxcsoftware.lxcupgrade": {
      "type": "method",
      "doc": "Requires that selected devices have already version_to_upgrade\n\nArgs:\n    devices (List[DeviceDetailsResponse]): For those devices software will be activated\n    version_to_upgrade (Optional[str]): version to be set as current version\n    image (Optional[str]): software image name in available files\n\n    Notice: Have to pass one of those arguments (version_to_activate, image)\n\nRaises:\n    EmptyVersionPayloadError: If selected version_to_activate or image not detected in available files\n\nReturns:\n    str: Activate software action id",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', version_to_upgrade: 'Optional[str]' = '', image: 'Optional[str]' = '') -> 'Task'"
    },
    "lxcsoftware.repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "lxcsoftware.repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "lxcsoftware.repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "lxcsoftware.repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "lxcsoftware.repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "lxcsoftware.repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "lxcsoftware.repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "omp.get_advertised_routes": {
      "type": "method",
      "doc": "Gets OMP advertised routes data for a device.\n\nArgs:\n    device_id (str): device ID (usually system-ip)\n\nReturns:\n    List[OmpAdvertisedRouteData]: OmpAdvertisedRouteData objects",
      "signature": "(device_id: 'str') -> 'List[OmpAdvertisedRouteData]'"
    },
    "omp.get_advertised_tlocs": {
      "type": "method",
      "doc": "Gets OMP advertised TLOCs data for a device.\n\nArgs:\n    device_id (str): device_id: device ID (usually system-ip)\n\nReturns:\n    List[OmpAdvertisedTlocData]: OmpAdvertisedTlocData objects",
      "signature": "(device_id: 'str') -> 'List[OmpAdvertisedTlocData]'"
    },
    "omp.get_omp_peers": {
      "type": "method",
      "doc": "Gets OMP peers for a device.\n\nArgs:\n    device_id (str): device ID (usually system-ip)\n\nReturns:\n    List[OmpPeerData]: OmpPeerData object",
      "signature": "(device_id: 'str') -> 'List[OmpPeerData]'"
    },
    "omp.get_omp_summary": {
      "type": "method",
      "doc": "Gets OMP summaries data for a device.\n\nArgs:\n    device_id (str): device ID (usually system-ip)\n\nReturns:\n    List[OmpSummaryData]: OmpSummaryData objects",
      "signature": "(device_id: 'str') -> 'List[OmpSummaryData]'"
    },
    "omp.get_received_routes": {
      "type": "method",
      "doc": "Gets OMP received routes data for a device.\n\nArgs:\n    device_id (str): device ID (usually system-ip)\n\nReturns:\n    List[OmpReceivedRouteData]: OmpReceivedRouteData objects",
      "signature": "(device_id: 'str') -> 'List[OmpReceivedRouteData]'"
    },
    "omp.get_received_tlocs": {
      "type": "method",
      "doc": "Gets OMP received TLOCs for a device.\n\nArgs:\n    device_id (str): device ID (usually system-ip)\n\nReturns:\n    List[OmpReceivedTlocData]: OmpReceivedTlocData objects",
      "signature": "(device_id: 'str') -> 'List[OmpReceivedTlocData]'"
    },
    "omp.get_services": {
      "type": "method",
      "doc": "Gets OMP services data for a device.\n\nArgs:\n    device_id (str): device ID (usually system-ip)\n\nReturns:\n    List[OmpServiceData]: OmpServiceData objects",
      "signature": "(device_id: 'str') -> 'List[OmpServiceData]'"
    },
    "packet_capture.channel": {
      "type": "method",
      "doc": "Creates packet capture session.\n\nArgs:\n    device (Device): Device class object\n\nRaises:\n    PermissionError: if already another packet capture session is active\n\nYields:\n    Iterator: packet_channel which contains session ID",
      "signature": "(device: 'Device') -> 'Iterator'"
    },
    "packet_capture.download_capture_session": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(packet: 'PacketSetup', device: 'Device', file_path: 'Optional[str]' = None) -> 'bool'"
    },
    "packet_capture.get_interface_name": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(device: 'Device') -> 'str'"
    },
    "packet_capture.get_packets": {
      "type": "method",
      "doc": "Initiate packet capture process.\n\nArgs:\n    device (Device): Device class object\n    duration_seconds (int, optional): Duration od packet capturing . Defaults to 20.\n\nReturns:\n    Status",
      "signature": "(device: 'Device', duration_seconds=120) -> 'Status'"
    },
    "packet_capture.get_status": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(packet_channel: 'PacketSetup') -> 'Status'"
    },
    "packet_capture.start_stop": {
      "type": "method",
      "doc": "Start and stops packet capturing.\n\nYields:\n    Iterator: None",
      "signature": "(device: 'Device') -> 'Iterator'"
    },
    "partition.device_version.get_device_available": {
      "type": "method",
      "doc": "Create devices payload list included requested, if requested version\nis in available versions\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\n\nReturns:\n    list : list of devices",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "partition.device_version.get_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'List[PartitionDevice]'"
    },
    "partition.device_version.get_device_list_in_installed": {
      "type": "method",
      "doc": "Create devices payload list included requested version, if requested version\nis in installed versions\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "partition.device_version.get_devices_available_versions": {
      "type": "method",
      "doc": "Create devices payload list included available software versions key\nfor every device in devices list\n\nArgs:\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "partition.device_version.get_devices_current_version": {
      "type": "method",
      "doc": "Create devices payload list included current software version key\nfor every device in devices list\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "partition.device_version.get_lxcactivate_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[LxcActivateDevice]'"
    },
    "partition.device_version.get_lxcupgrade_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[LxcUpgradeDevice]'"
    },
    "partition.device_version.repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "partition.device_version.repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "partition.device_version.repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "partition.device_version.repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "partition.device_version.repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "partition.device_version.repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "partition.device_version.repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "partition.remove_partition": {
      "type": "method",
      "doc": "Remove chosen software version from device\n\nArgs:\n    devices (DataSequence[Device]): remove partition for those devices\n    partition (str): If none, all availables partitions will be removed,\n        else selected partition will be removed\n    force (bool): bypass version checks\n\nReturns:\n    str: action id",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', partition: 'Optional[str]' = None, force: 'bool' = False) -> 'Task'"
    },
    "partition.repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "partition.repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "partition.repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "partition.repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "partition.repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "partition.repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "partition.repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "partition.set_default_partition": {
      "type": "method",
      "doc": "Set default software versions for devices\n\nArgs:\n    devices (DataSequence[Device]): devices\n    partition (Optional[str], optional): If none, current partition will be set as default,\n        else selected partition will be set as default\n\nReturns:\n    str: set partition task id",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', partition: 'Optional[str]' = None) -> 'Task'"
    },
    "policy.centralized.activate": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID') -> 'Task'"
    },
    "policy.centralized.check_vsmart_connectivity": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'DataSequence[VSmartConnectivityStatus]'"
    },
    "policy.centralized.create": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy: 'CentralizedPolicy') -> 'UUID'"
    },
    "policy.centralized.deactivate": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID') -> 'Task'"
    },
    "policy.centralized.delete": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID') -> 'None'"
    },
    "policy.centralized.edit": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy: 'CentralizedPolicyEditPayload', lock_checks: 'bool' = True) -> 'None'"
    },
    "policy.centralized.get": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'Optional[UUID]' = None) -> 'Any'"
    },
    "policy.definitions.create": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy_definition: 'AnyPolicyDefinition') -> 'UUID'"
    },
    "policy.definitions.delete": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(type: 'Type[AnyPolicyDefinition]', id: 'UUID') -> 'None'"
    },
    "policy.definitions.edit": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID', policy_definition: 'AnyPolicyDefinition') -> 'PolicyDefinitionEditResponse'"
    },
    "policy.definitions.get": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(type: 'Type[AnyPolicyDefinition]', id: 'Optional[UUID]' = None) -> 'Any'"
    },
    "policy.delete_any": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(_type: 'Any', id: 'UUID') -> 'None'"
    },
    "policy.get_protocol_map": {
      "type": "method",
      "doc": "No documentation",
      "signature": "() -> 'Dict[str, ApplicationProtocol]'"
    },
    "policy.lists.create": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy_list: 'AnyPolicyList') -> 'UUID'"
    },
    "policy.lists.delete": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(type: 'Type[AnyPolicyList]', id: 'UUID') -> 'None'"
    },
    "policy.lists.edit": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID', policy_list: 'AnyPolicyList') -> 'None'"
    },
    "policy.lists.get": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(type: 'Type[AnyPolicyList]', id: 'Optional[UUID]' = None) -> 'Any'"
    },
    "policy.localized.create": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy: 'LocalizedPolicy') -> 'UUID'"
    },
    "policy.localized.delete": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID') -> 'None'"
    },
    "policy.localized.edit": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID', policy: 'LocalizedPolicy') -> 'LocalizedPolicyEditResponse'"
    },
    "policy.localized.get": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'Optional[UUID]' = None) -> 'Any'"
    },
    "policy.localized.list_devices": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'Optional[UUID]' = None) -> 'DataSequence[LocalizedPolicyDeviceInfo]'"
    },
    "policy.localized.preview": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID') -> 'str'"
    },
    "policy.security.create": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(policy: 'AnySecurityPolicy') -> 'UUID'"
    },
    "policy.security.delete": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID') -> 'None'"
    },
    "policy.security.edit": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'UUID', policy: 'AnySecurityPolicy') -> 'SecurityPolicyEditResponse'"
    },
    "policy.security.get": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(id: 'Optional[UUID]' = None) -> 'Any'"
    },
    "repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "resource_groups.create": {
      "type": "method",
      "doc": "Creates a new resource group\n\nArgs:\n    resource_group (ResourceGroup): Definition of new resource group to be created",
      "signature": "(resource_group: 'ResourceGroup')"
    },
    "resource_groups.delete": {
      "type": "method",
      "doc": "Deletes a given resource group\n\nArgs:\n    resource_group_id (str): Resource group id",
      "signature": "(resource_group_id: 'str')"
    },
    "resource_groups.get": {
      "type": "method",
      "doc": "List all resource groups\n\nReturns:\n    DataSequence[ResourceGroup]: List-like object containing user groups information",
      "signature": "() -> 'DataSequence[ResourceGroup]'"
    },
    "resource_groups.switch": {
      "type": "method",
      "doc": "Switch to view only a specific resource group (for global admin only)\n\nArgs:\n    resource_group_name (str): Name of resource group to switch view",
      "signature": "(resource_group_name: 'str')"
    },
    "resource_groups.update": {
      "type": "method",
      "doc": "Updates existing resource group\n\nArgs:\n    resource_group_update_request (ResourceGroupUpdateRequest): Object containing existing\n    resource group id and attributes to be updated",
      "signature": "(resource_group_update_request: 'ResourceGroupUpdateRequest')"
    },
    "resource_pool.create": {
      "type": "method",
      "doc": "Create device vpn.\n\nReturns:\n    DataSequence[ResourcePoolData].",
      "signature": "() -> 'DataSequence[ResourcePoolData]'"
    },
    "resource_pool.delete": {
      "type": "method",
      "doc": "Delete device vpn for tenant.\n\nArgs:\n    tenant_id: The tenant id.\n    tenant_vpn: The number of tenant vpn.\n\nReturns:\n    bool: True if all ok, False like something wrong\n\nTODO note - tenant id doesn't work, need to enter tenant organization name.",
      "signature": "(tenant_id: 'str', tenant_vpn: 'int') -> 'bool'"
    },
    "resource_pool.get": {
      "type": "method",
      "doc": "Get device vpn for tenant.\n\nArgs:\n    tenant_id: The tenant id.\n    tenant_vpn: The number of tenant vpn.\n\nReturns:\n    DataSequence[ResourcePoolData] for tenant.\n\nTODO note - tenant id doesn't work, need to enter tenant organization name.",
      "signature": "(tenant_id: 'str', tenant_vpn: 'int') -> 'DataSequence[ResourcePoolData]'"
    },
    "sd_routing_feature_profiles.cli.create": {
      "type": "method",
      "doc": "Creates CLI feature profile",
      "signature": "(name: 'str', description: 'str') -> 'FeatureProfileCreationResponse'"
    },
    "sd_routing_feature_profiles.cli.delete": {
      "type": "method",
      "doc": "Deletes CLI feature-profile",
      "signature": "(fp_id: 'str') -> 'None'"
    },
    "sd_routing_feature_profiles.cli.endpoint.create_cli_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.cli.endpoint.create_cli_full_config_parcel": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.cli.endpoint.delete_cli_feature_profile": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.cli.endpoint.delete_cli_full_config_parcel": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.cli.endpoint.edit_cli_full_config_parcel": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.cli.endpoint.get_cli_feature_profiles": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.cli.init_parcels": {
      "type": "method",
      "doc": "Initialize CLI full-config parcel associated with this feature profile",
      "signature": "(fp_id: 'str') -> 'None'"
    },
    "sd_routing_feature_profiles.policy_object.create": {
      "type": "method",
      "doc": "Create Policy Object for selected profile_id based on payload type",
      "signature": "(profile_id: 'UUID', payload: 'AnyPolicyObjectParcel') -> 'ParcelCreationResponse'"
    },
    "sd_routing_feature_profiles.policy_object.delete": {
      "type": "method",
      "doc": "Delete Policy Object for selected profile_id based on payload type",
      "signature": "(profile_id: 'UUID', parcel_type: 'Type[AnyPolicyObjectParcel]', list_object_id: 'UUID') -> 'None'"
    },
    "sd_routing_feature_profiles.policy_object.endpoint.create": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.policy_object.endpoint.delete": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.policy_object.endpoint.get_all": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.policy_object.endpoint.get_by_id": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.policy_object.endpoint.update": {
      "type": "method",
      "doc": "Executes each time decorated method is called",
      "signature": "(*args, **kwargs)"
    },
    "sd_routing_feature_profiles.policy_object.get": {
      "type": "method",
      "doc": "Get all Policy Objects for selected profile_id and selected type or get one Policy Object given parcel id",
      "signature": "(profile_id: 'UUID', parcel_type: 'Type[AnyPolicyObjectParcel]', parcel_id: 'Union[UUID, None]' = None) -> 'DataSequence[Parcel[Any]]'"
    },
    "sd_routing_feature_profiles.policy_object.update": {
      "type": "method",
      "doc": "Update Policy Object for selected profile_id based on payload type",
      "signature": "(profile_id: 'UUID', payload: 'AnyPolicyObjectParcel', list_object_id: 'UUID')"
    },
    "sessions.get": {
      "type": "method",
      "doc": "List all active sessions\n\nReturns:\n    DataSequence[ActiveSession]: List-like object representing active user sessions",
      "signature": "() -> 'DataSequence[ActiveSession]'"
    },
    "sessions.invalidate": {
      "type": "method",
      "doc": "Invalidates given sessions\n\nArgs:\n    sessions (List[ActiveSession]): List of active sessions\n\nReturns:\n    InvalidateSessionMessage: Information about invalidation result",
      "signature": "(sessions: 'List[ActiveSession]') -> 'InvalidateSessionMessage'"
    },
    "software.activate": {
      "type": "method",
      "doc": "Set chosen version as current version. Requires that selected devices have already version_to_activate\nor image present in their available files.\n\nArgs:\n    devices (List[DeviceDetailsResponse]): For those devices software will be activated\n    version_to_activate (Optional[str]): version to be set as current version\n    image (Optional[str]): software image name in available files\n\n    Notice: Have to pass one of those arguments (version_to_activate, image)\n\nRaises:\n    EmptyVersionPayloadError: If selected version_to_activate or image not detected in available files\n\nReturns:\n    str: Activate software action id",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', version_to_activate: 'Optional[str]' = '', image: 'Optional[str]' = '') -> 'Task'"
    },
    "software.device_versions.get_device_available": {
      "type": "method",
      "doc": "Create devices payload list included requested, if requested version\nis in available versions\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\n\nReturns:\n    list : list of devices",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "software.device_versions.get_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'List[PartitionDevice]'"
    },
    "software.device_versions.get_device_list_in_installed": {
      "type": "method",
      "doc": "Create devices payload list included requested version, if requested version\nis in installed versions\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "software.device_versions.get_devices_available_versions": {
      "type": "method",
      "doc": "Create devices payload list included available software versions key\nfor every device in devices list\n\nArgs:\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "software.device_versions.get_devices_current_version": {
      "type": "method",
      "doc": "Create devices payload list included current software version key\nfor every device in devices list\n\nArgs:\n    version_to_set_up (str): requested version\n    devices (List[DeviceDetailsResponse]): devices on which action going to be performed\n\nReturns:\n    list : list of devices",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[PartitionDevice]'"
    },
    "software.device_versions.get_lxcactivate_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[LxcActivateDevice]'"
    },
    "software.device_versions.get_lxcupgrade_device_list": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(version_to_set_up: 'str', devices: 'DataSequence[DeviceDetailsResponse]') -> 'DataSequence[LxcUpgradeDevice]'"
    },
    "software.device_versions.repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "software.device_versions.repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "software.device_versions.repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "software.device_versions.repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "software.device_versions.repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "software.device_versions.repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "software.device_versions.repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "software.install": {
      "type": "method",
      "doc": "Method to install new software\n\nArgs:\n    devices (List[DeviceDetailsResponse]): For those devices software will be activated\n    reboot (bool, optional): reboot device after action end\n    sync (bool, optional): Synchronize settings. Defaults to True.\n    v_edge_vpn (int, optional): vEdge VPN\n    v_smart_vpn (int, optional): vSmart VPN\n    image (str): path to software image or its name from available files\n    image_version (str): version of software image\n    downgrade_check (bool, optional): perform a downgrade check when applicable\n    remote_server_name (str): name of configured Remote Server\n    remote_image_filename (str): filename to choose from selected Remote Server\n\n    Notice: Have to pass one of those:\n        - image_version\n        - image\n        - remote_server_name and remote_image_filename\n\nRaises:\n    ValueError: Raise error if downgrade in certain cases or wrong arguments combination provided\n    ImageNotInRepositoryError: If selected image, image_version or remote_image_filename not found\n\nReturns:\n    Task: Task object representing started install process",
      "signature": "(devices: 'DataSequence[DeviceDetailsResponse]', reboot: 'bool' = False, sync: 'bool' = True, v_edge_vpn: 'int' = 0, v_smart_vpn: 'int' = 0, image: 'Optional[str]' = None, image_version: 'Optional[str]' = None, downgrade_check: 'bool' = True, remote_server_name: 'Optional[str]' = None, remote_image_filename: 'Optional[str]' = None) -> 'Task'"
    },
    "software.repository.delete_image": {
      "type": "method",
      "doc": "Delete image from vManage software repository\n\nArgs:\n    image_name (str): image name (in available files)\n\nRaises:\n    ImageNotInRepositoryError: raise error if image not in repository\n\nReturns:\n    int: Reponse status code",
      "signature": "(image_name: 'str') -> 'None'"
    },
    "software.repository.get_all_software_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "software.repository.get_all_virtual_images": {
      "type": "method",
      "doc": "Get all info about all software images stored in Vmanage repository\n\nReturns:\n    list: software images list",
      "signature": "() -> 'DataSequence[SoftwareImageDetails]'"
    },
    "software.repository.get_devices_versions_repository": {
      "type": "method",
      "doc": "Create DeviceSoftwareRepository dataclass,\nwhich cointains information about all possible version types for certain devices\n\nReturns:\n    Dict[str, DeviceSoftwareRepository]: Dictionary containing all versions\n    information",
      "signature": "() -> 'Dict[str, DeviceSoftwareRepository]'"
    },
    "software.repository.get_image_version": {
      "type": "method",
      "doc": "Get proper software image version, based on name in available files.\n\nIf software_image detected in available files, but doesn't include version_name, software_image won't be used.\n\nArgs:\n    software_image (str): path to software image\n\nReturns:\n    Union[str, None]: image version or None",
      "signature": "(software_image: 'str') -> 'Union[str, None]'"
    },
    "software.repository.get_remote_image": {
      "type": "method",
      "doc": "Get remote software image details, based on name in available files and remote server name.\n\nArgs:\n    remote_image_filename (str): path to software image on remote server\n    remote_server_name (str): remote server name\n\nReturns:\n    Union[SoftwareImageDetails, None]: remote image image details",
      "signature": "(remote_image_filename: 'str', remote_server_name: 'str') -> 'Union[SoftwareImageDetails, None]'"
    },
    "software.repository.upload_image": {
      "type": "method",
      "doc": "Upload software image ('tar.gz' or 'SPA.bin') to vManage software repository\n\nArgs:\n    image_path (str): path to software image\n\nReturns:\n    str: Response status code",
      "signature": "(image_path: 'str') -> 'None'"
    },
    "speedtest.speedtest": {
      "type": "method",
      "doc": "Performs speedtest between 2 edge devices.\n\nArgs:\n    source_device (Device): device from which the speed will be measured\n    destination_device (Device): device to which the speed will be measured\n    test_duration_seconds (int): duration of the speed measuring in seconds, defaults to 300 (5 minutes)",
      "signature": "(source_device: 'Device', destination_device: 'Device', test_duration_seconds: 'int' = 300) -> 'Speedtest'"
    },
    "templates.attach": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(name: 'str', device: 'Device', timeout_seconds: 'int' = 300, **kwargs)"
    },
    "templates.create": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template, debug: 'bool' = False)"
    },
    "templates.create_by_generator": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template: 'FeatureTemplate', debug: 'bool') -> 'str'"
    },
    "templates.deatach": {
      "type": "method",
      "doc": "Deatach it`s the same to change device mode to CLI mode.\n\nArgs:\n    device (Device): Device to deatach template (change mode).\n\nReturns:\n    bool: True if change deatach template (mode to CLI) is successful, otherwise - False.",
      "signature": "(device: 'Device') -> 'bool'"
    },
    "templates.delete": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template, name)"
    },
    "templates.edit": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template)"
    },
    "templates.edit_before_push": {
      "type": "method",
      "doc": "Edits device / CLI template before pushing modified config to device(s)\n\nArgs:\n    name (str): Template name to edit.\n    device (Device): Device to attach template.\n\nReturns:\n    bool: True if edit template is successful, otherwise - False.",
      "signature": "(name: 'str', device: 'Device') -> 'bool'"
    },
    "templates.generate_feature_template_payload": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template: 'FeatureTemplate', schema: 'Any', debug: 'bool' = False) -> 'FeatureTemplatePayload'"
    },
    "templates.get": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template)"
    },
    "templates.get_device_configuration_preview": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(payload: 'FeatureToCLIPayload') -> 'CiscoConfParse'"
    },
    "templates.get_feature_template_schema": {
      "type": "method",
      "doc": "No documentation",
      "signature": "(template: 'FeatureTemplate', debug: 'bool' = False) -> 'Any'"
    },
    "templates.is_created_by_generator": {
      "type": "method",
      "doc": "Checks if template is created by generator\n\nMethod will be deleted if every template's payload will be generated dynamically.",
      "signature": "(template: 'FeatureTemplate') -> 'bool'"
    },
    "templates.load_running": {
      "type": "method",
      "doc": "Load running config from device.\n\nArgs:\n    device: The device from which load config.\n\nReturns:\n    CiscoConfParse: A working configuration on the machine.",
      "signature": "(device: 'Device') -> 'CiscoConfParse'"
    },
    "templates.template_validation": {
      "type": "method",
      "doc": "Checking the template of the configuration on the machine.\n\nArgs:\n    id (str): template id to check.\n    device (Device): The device on which the configuration is to be validate.\n\nReturns:\n    str: Validated config.",
      "signature": "(id: 'str', device: 'Device') -> 'str'"
    },
    "templates.validate_device_model": {
      "type": "method",
      "doc": "Verify if selected template can be used with provided device model",
      "signature": "(template: 'FeatureTemplate') -> 'bool'"
    },
    "tenant_backup.delete": {
      "type": "method",
      "doc": "Delete tenant backup file\n\nArgs:\n    file (str): device ID (usually system-ip)\n\nReturns:\n    http response for delete operation\n\nExample usage:\n    message = ProviderBackupRestore.delete(fileName)",
      "signature": "(file: 'str') -> 'List[str]'"
    },
    "tenant_backup.delete_all": {
      "type": "method",
      "doc": "Delete all tenant backup files\n\nReturns:\n    http response for delete operation\n\nExample usage:\n    message = ProviderBackupRestore.delete_all()",
      "signature": "() -> 'List[str]'"
    },
    "tenant_backup.download": {
      "type": "method",
      "doc": "Download tenant backup file\n\nArgs:\n    file: full path or base name of tenant backup file\n    download_dir: download directory (defaul: current working directory)\n\nReturns:\n    Path to downloaded tenant backup file\n\nExample usage:\n    file = ProviderBackupRestore.download(fileName)",
      "signature": "(file: 'str', download_dir: 'Optional[Path]' = None) -> 'Path'"
    },
    "tenant_backup.export": {
      "type": "method",
      "doc": "Export tenant backup file from DB to vManage storage\n\nArgs:\n    timeout: Max polling time for task (default: 300 seconds)\n\nReturns:\n    str: filename of exported tenant backup file stored on vManage\n\nExample usage:\n    fileName = ProviderBackupRestore.export()",
      "signature": "(timeout: 'int' = 300) -> 'str'"
    },
    "tenant_backup.import_file": {
      "type": "method",
      "doc": "Upload the file for tenant import to the DB and poll for Success\n\nArgs:\n    file: The path of the file to be upladed\n    timeout: Max polling time for task (default: 300 seconds)\n\nReturns:\n    TaskStatus object with Success and Activity messages\n\nExample usage:\n     status = ProviderBackupRestore.import_file(file)",
      "signature": "(file: 'Path', timeout: 'int' = 300) -> 'SubTaskData'"
    },
    "tenant_backup.list": {
      "type": "method",
      "doc": "Return a list of backup files stored on vManage\n\nReturns:\n    list of filenames\n\nExample usage:\n    fileList = ProviderBackupRestore.list()",
      "signature": "() -> 'list'"
    },
    "tenant_management.create": {
      "type": "method",
      "doc": "Creates tenants on vManage\n\nArgs:\n    tenants (List[Tenant]): List of tenants to be created\n\nReturns:\n    Task: Object representing tenant creation process",
      "signature": "(tenants: 'List[Tenant]') -> 'Task'"
    },
    "tenant_management.delete": {
      "type": "method",
      "doc": "Deletes tenants on vManage\n\nArgs:\n    tenant_ids (List[str]): Tenant IDs to be deleted\n    password (Optional[str]): Provider password if not provided current session password will be used\n\nReturns:\n    Task: Object representing tenant deletion process",
      "signature": "(tenant_id_list: 'List[str]', password: 'str') -> 'Task'"
    },
    "tenant_management.get": {
      "type": "method",
      "doc": "Lists all the tenants on the vManage.\n\nIn a multitenant vManage system, this API is only avaiable in the Provider view.\n\nReturns:\n    DataSequence[TenantInfo]: List-like object containing tenant information",
      "signature": "() -> 'DataSequence[Tenant]'"
    },
    "tenant_management.get_hosting_capacity_on_vsmarts": {
      "type": "method",
      "doc": "Gets tenant hosting capacity on vSmarts\n\nReturns:\n    DataSequence[vSmartTenantCapacity]: List-like object containing tenant capacity information for each vSmart",
      "signature": "() -> 'DataSequence[vSmartTenantCapacity]'"
    },
    "tenant_management.get_statuses": {
      "type": "method",
      "doc": "Gets tenant statuses from vManage\n\nReturns:\n    DataSequence[TenantStatus]: List-like object containing tenants statuses",
      "signature": "() -> 'DataSequence[TenantStatus]'"
    },
    "tenant_management.get_vsmart_mapping": {
      "type": "method",
      "doc": "Gets vSmart to tenant mapping\n\nReturns:\n    vSmartTenantMap: Contains vSmart to tenant mapping",
      "signature": "() -> 'vSmartTenantMap'"
    },
    "tenant_management.update": {
      "type": "method",
      "doc": "Updates Tenant on vManage\n\nArgs:\n    tenant_update_request (TenantUpdateRequest): Tenant attributes to be updated (must contain tenantId)\n\nReturns:\n    Tenant: Updated tenant data",
      "signature": "(tenant_update_request: 'TenantUpdateRequest') -> 'Tenant'"
    },
    "tenant_management.update_vsmart_placement": {
      "type": "method",
      "doc": "Updates vSmart placement\n\nArgs:\n    tenant_id (str): Tenant ID\n    src_vsmart_uuid (str): Source vSmart uuid\n    dst_vsmart_uuid (str): Destination vSmart uuid",
      "signature": "(tenant_id: 'str', src_vsmart_uuid: 'str', dst_vsmart_uuid: 'str')"
    },
    "tenant_management.vsession_id": {
      "type": "method",
      "doc": "Gets VSessionId for given tenant\n\nArgs:\n    tenant_id (str): Tenant ID\n\nReturns:\n    str: Contains VSessionId for given tenant",
      "signature": "(tenant_id: 'str') -> 'str'"
    },
    "tenant_migration.download": {
      "type": "method",
      "doc": "Download exported deployment and configuration data from a Cisco vManage instance\nto a local file system. Should be executed on migration origin.\n\nArgs:\n    download_path (Path): full download path containing a filename eg.: Path(\"/home/user/tenant-export.tar.gz\")\n    remote_filename (str): path to exported tenant migration file on vManage",
      "signature": "(download_path: 'Path', remote_filename: 'str' = 'default.tar.gz')"
    },
    "tenant_migration.export_tenant": {
      "type": "method",
      "doc": "Exports the deployment and configuration data from a Cisco vManage instance.\nShould be executed on migration origin.\n\nArgs:\n    tenant (Tenant): Tenant object containig required fields: desc, name, subdomain, org_name\n\nReturns:\n    Task: object representing initiated export process",
      "signature": "(tenant: 'TenantExport') -> 'ExportTask'"
    },
    "tenant_migration.import_tenant": {
      "type": "method",
      "doc": "Imports the deployment and configuration data into multi-tenant vManage instance.\nShould be executed on migration target.\n\nArgs:\n    import_file (Path): full path to previously exported data file\n    migration_key (str): migration key (required starting from 20.13)\n\nReturns:\n    ImportTask: object representing initiated import process",
      "signature": "(import_file: 'Path', migration_key: 'Optional[str]' = None) -> 'ImportTask'"
    },
    "tenant_migration.migrate_network": {
      "type": "method",
      "doc": "Starts migration procedure on migration origin.\n\nArgs:\n    token_file (Path): full path to previously stored text file with import token.\n\nReturns:\n    Task: object representing initiated migration process",
      "signature": "(token_file: 'Path') -> 'Task'"
    },
    "tenant_migration.store_token": {
      "type": "method",
      "doc": "Stores migration token as text file for given migration identifier.\nShould be executed on migration target.\n\nArgs:\n    migration_id (str): migration identifier (it is obtained after import tenant task is finished)\n    download_path (Path): full download path containing a filename eg.: Path(\"/home/user/import-token.txt\")",
      "signature": "(migration_id: 'str', download_path: 'Path')"
    },
    "user_groups.create": {
      "type": "method",
      "doc": "Creates a new user group\n\nArgs:\n    user_group (UserGroup): Definition of user group to be created",
      "signature": "(user_group: 'UserGroup')"
    },
    "user_groups.delete": {
      "type": "method",
      "doc": "Deletes given user group\n\nArgs:\n    group_name (str): Name of the user group to be deleted",
      "signature": "(group_name: 'str')"
    },
    "user_groups.get": {
      "type": "method",
      "doc": "List all user groups\n\nReturns:\n    DataSequence[UserGroup]: List-like object representing user groups",
      "signature": "() -> 'DataSequence[UserGroup]'"
    },
    "user_groups.update": {
      "type": "method",
      "doc": "Updates existing user group\n\nArgs:\n    user_group (UserGroup): User group attributes to be updated",
      "signature": "(user_group: 'UserGroup')"
    },
    "users.create": {
      "type": "method",
      "doc": "Creates a new user\n\nArgs:\n    user (User): Definition of new user to be created",
      "signature": "(user: 'User')"
    },
    "users.delete": {
      "type": "method",
      "doc": "Deletes given user\n\nArgs:\n    username (str): Name of the user to be deleted",
      "signature": "(username: 'str')"
    },
    "users.get": {
      "type": "method",
      "doc": "List all users\n\nReturns:\n    DataSequence[User]: List-like object representing users",
      "signature": "() -> 'DataSequence[User]'"
    },
    "users.get_auth_type": {
      "type": "method",
      "doc": "Get currently logged user authentication type\n\nReturns:\n    str: Currently logged user authentication type",
      "signature": "() -> 'str'"
    },
    "users.get_role": {
      "type": "method",
      "doc": "Get currently logged user role\n\nReturns:\n    UserRole: Currently logged user role information",
      "signature": "() -> 'UserRole'"
    },
    "users.reset": {
      "type": "method",
      "doc": "Resets given user (unlocks blocked user eg. after number of unsuccessfull login attempts)\n\nArgs:\n    username (str): Name of the user to be unlocked",
      "signature": "(username: 'str')"
    },
    "users.update": {
      "type": "method",
      "doc": "Updates existing user\n\nArgs:\n    user_update_request (UserUpdateRequest): User attributes to be updated",
      "signature": "(user_update_request: 'UserUpdateRequest')"
    },
    "users.update_password": {
      "type": "method",
      "doc": "Updates exisiting user password\n\nArgs:\n    username (str): Name of the user\n    new_password (str): New password for given user",
      "signature": "(username: 'str', new_password: 'str', current_user_password: 'str')"
    }
  },
  "total_endpoints": 130,
  "total_methods": 723
}